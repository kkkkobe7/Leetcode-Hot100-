# 39. 组合总和

解题思路拆解

**1. 核心模型：搜索决策树**
*   想象你面前有一排硬币（`candidates`），你的目标是凑够 `target`。
*   对于每一个位置，你可以选择拿起当前的硬币，也可以跳过去看下一个。
*   因为硬币可以**重复使用**，当你拿起一个面额为 2 的硬币后，你的下一轮选择依然可以包含这个面额为 2 的硬币。

**2. 递归状态定义**
*   `k`: 当前我们正在考虑的数字下标（从 `candidates[k]` 开始往后选）。
*   `sum`: 当前已经凑出来的总和。
*   `cur`: 记录当前路径中已经选了哪些数字。

**3. 如何避免重复组合？**
*   **重复组合的问题**：比如 `[2, 2, 3]` 和 `[3, 2, 2]` 是同一种组合。
*   **解决方案**：我们在搜索时设定一个**顺序**。如果当前选了下标为 `k` 的数字，那么下一层递归只在下标 `[k, n-1]` 的范围内选。这样保证了结果数组一定是**非递减**的（按原数组顺序），从而杜绝了乱序导致的重复。

**4. 剪枝与终止**
* **成功**：如果 `sum == target`，保存当前路径。

* **失败（剪枝）**：如果 `sum > target`，说明这一条路走得太远了，再加数只会更大，直接回头。

    

简洁版代码：

```c++
class Solution {
public:
    vector<vector<int>> ans;

    bool dfs(vector<int>& candidates, vector<int>& cur, int k, int sum, int target) // 当前遍历candidates[k]
    {
        if (sum > target) return true; // 如果超出，后续循环也不需要继续

        cur.push_back(candidates[k]);
        sum += candidates[k];

        if (sum == target)
        {
            ans.push_back(cur);
        }
        else
        {
            int n = candidates.size();
            bool tag = false;
            for (int j = k; j < n; j ++)
            {
                tag = dfs(candidates, cur, j, sum, target);
                if (tag) break;
            }
        }
        cur.pop_back();
        return false;
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        int n = candidates.size();
        for (int i = 0; i < n; i ++)
        {
            vector<int> t;
            dfs(candidates, t, i, 0, target);
        }

        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    vector<vector<int>> ans;

    // 返回值 bool：代表是否已经超标 (sum > target)
    bool dfs(vector<int>& candidates, vector<int>& cur, int k, int sum, int target) 
    {
        // 1. 基础检查：如果当前和已经超标
        if (sum > target) return true; // 返回 true，告诉父节点：后面更大的数不用试了

        // 2. 尝试放入当前数字
        cur.push_back(candidates[k]);
        sum += candidates[k];

        // 3. 检查是否达成目标
        if (sum == target)
        {
            ans.push_back(cur);
            // 达成目标后，由于数组是升序的，同一个位置再放后面更大的数肯定会超标
            // 所以这里虽然逻辑上可以继续，但实际上后面也会触发 sum > target
        }
        else
        {
            int n = candidates.size();
            // 4. 递归探索子节点
            for (int j = k; j < n; j ++)
            {
                // tag 接收子递归的反馈
                bool tag = dfs(candidates, cur, j, sum, target);
                
                // 【核心剪枝】：如果子递归告诉我它已经超标了
                if (tag) {
                    break; // 立即跳出当前循环，不再尝试 candidates[j+1...n-1]
                }
            }
        }

        // 5. 回溯：清理现场
        cur.pop_back();
        
        // 此处返回 false，表示当前层逻辑执行完毕，
        // 只有在 sum > target 的那个出口才会返回 true
        return false;
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        ans.clear();
        
        // 【关键步骤】：预排序，这是后续所有剪枝逻辑的前提
        sort(candidates.begin(), candidates.end());
        
        int n = candidates.size();
        for (int i = 0; i < n; i ++)
        {
            vector<int> t;
            // 如果第一个数就比 target 大，后面不用看了
            if (candidates[i] > target) break; 
            
            dfs(candidates, t, i, 0, target);
        }

        return ans;
    }
};
```

