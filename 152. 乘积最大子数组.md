# 152. 乘积最大子数组

### 解题思路拆解

**1. 核心矛盾：负数的“翻转”能力**

- 在求“和”的时候，遇到负数只会让结果变小，我们只希望前面的和是正的。
- 在求“乘积”的时候，遇到负数很特殊：如果当前是负数，且前面累积了一个**很大的正数**，乘完就会变成一个**很小的负数**。但如果前面累积了一个**很小的负数**（比如 -10000），乘完就会变成一个**很大的正数**（+20000）！
- **结论：** 我们不能只维护一个“最大值”，必须同时维护一个**“最小值”**（因为最小值可能随时翻身做主人）。

**2. 定义状态 (DP Table)**

- `f[i][1]` (Max)：以第 i 个元素结尾的**最大乘积**。
- `f[i][0]` (Min)：以第 i 个元素结尾的**最小乘积**。

**3. 状态转移逻辑**

- **情况 A：当前数 nums[i] 是负数**最大的变成了最小的（Max * 负数 = 很小的负数）。最小的变成了最大的（Min * 负数 = 很大的正数）。所以：我们要用昨天的“最小值”去乘今天的负数，来争取得到今天的“最大值”。
- **情况 B：当前数 nums[i] 是正数**强者恒强：昨天的最大值 * 正数 = 更大的最大值。弱者恒弱：昨天的最小值 * 正数 = 更小的最小值。

**4. 为什么还要跟自己比较？**

- 状态转移方程里不仅要乘以前面的，还要跟 nums[i] 自己比。
- max(prev * nums[i], nums[i])。
- 这代表：如果前面的累积结果太糟糕了（比如前面是 0，或者是分数），不如**另起炉灶**，从当前这个数重新开始计算子数组。
- 

简洁版代码：

```c++
class Solution {
public:
    static const int N = 2e4 + 10;
    int f[N][2]; // f[i][0]代表负数结果，f[i][1]代表正数结果

    int maxProduct(vector<int>& nums) {
        int n = nums.size(), ans = nums[0];

        if (nums[0] < 0) f[0][0] = nums[0];
        else f[0][1] = nums[0];

        for (int i = 1; i < n; i ++)
        {
            if (nums[i] < 0)
            {
                f[i][0] = min(f[i-1][1] * nums[i], nums[i]);
                f[i][1] = f[i-1][0] * nums[i];
            }
            else
            {
                f[i][0] = f[i-1][0] * nums[i];
                f[i][1] = max(f[i-1][1] * nums[i], nums[i]);
            }

            ans = max(ans, max(f[i][0], f[i][1]));
        }

        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 定义稍大，防止越界
    static const int N = 2e4 + 10;
    
    // DP 数组
    // f[i][0]: 以 nums[i] 结尾的 最小乘积 (通常是负数，或者是被 0 截断的数)
    // f[i][1]: 以 nums[i] 结尾的 最大乘积 (我们渴望的正数)
    int f[N][2]; 

    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        // ans 初始化为第一个元素
        int ans = nums[0];

        // 1. 初始化 (Base Case)
        // 您的写法是根据正负分别放入 f[0][0] 或 f[0][1]
        // 其实更通用的写法是：f[0][0] = f[0][1] = nums[0]; 
        // 这样无论正负，最大最小值初始都是它自己。
        if (nums[0] < 0) f[0][0] = nums[0]; // 如果是负数，它暂时归为“最小”一类
        else f[0][1] = nums[0];             // 如果是正数，它归为“最大”一类
        
        // 注意：C++ 全局/静态数组默认初始化为 0。
        // 如果 nums[0] 是负数，f[0][1] 默认为 0，这对后续乘法其实有隐患，
        // 但由于本题逻辑后续会覆盖，或者是 0 正好作为“截断点”，所以能通过。
        // 建议面试时显式初始化： f[0][0] = nums[0]; f[0][1] = nums[0];

        for (int i = 1; i < n; i ++)
        {
            // 2. 状态转移
            if (nums[i] < 0)
            {
                // 如果当前是负数：
                // 最小值 = min(昨天的最大值 * 当前负数, 当前负数本身)
                // 为什么要比较 nums[i]？因为如果 f[i-1][1] 是 0 或很小，不如从 nums[i] 重新开始
                f[i][0] = min(f[i-1][1] * nums[i], nums[i]);
                
                // 最大值 = 昨天的最小值 * 当前负数 (负负得正，这是核心！)
                // 注意：这里没有和 nums[i] 取 max，逻辑上是假设 f[i-1][0] 足够小。
                // 严谨写法推荐：f[i][1] = max(f[i-1][0] * nums[i], nums[i]);
                f[i][1] = f[i-1][0] * nums[i];
            }
            else
            {
                // 如果当前是正数：
                // 最小值 = 昨天的最小值 * 当前正数
                f[i][0] = f[i-1][0] * nums[i];
                
                // 最大值 = max(昨天的最大值 * 当前正数, 当前正数本身)
                // 同样，如果之前的积是负数或0，不如从当前正数重新开始
                f[i][1] = max(f[i-1][1] * nums[i], nums[i]);
            }

            // 3. 更新全局答案
            // 每一轮都要看看当前产生的最大值是不是历史最大的
            ans = max(ans, max(f[i][0], f[i][1]));
        }

        return ans;
    }
};
```

