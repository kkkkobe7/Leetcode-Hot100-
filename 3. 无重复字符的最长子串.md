# 3. 无重复字符的最长子串

参考[Krahets题解](https://leetcode.cn/u/jyd/)

解题思路拆解

**1. 核心模型：滑动窗口**
*   想象在字符串上有一个“窗口”，它的左边界是 `i`，右边界是 `j`。
*   我们的目标是：让这个窗口尽可能长，同时保证窗口内的字符不重复。

**2. 贪心策略：遇到重复怎么办？**
*   当右边界 `j` 向右移动并遇到一个重复字符时（比如 `a`），我们不需要把窗口推倒重来。
*   我们只需要把左边界 `i` **跳跃**到该重复字符上一次出现的位置。
*   这样，窗口内就再次排除了重复的 `a`。

**3. 哈希表的作用**
*   哈希表 `dic` 就像一个“记事本”，记录每个字符**最后一次出现的位置**。
*   当我们看到 `s[j]` 时，去查记事本。如果它在里面，说明它重复了，我们就直接拿到它的旧下标。

**4. 细节：左边界 `i` 的更新**
*   `i = max(i, dic[s[j]])`：为什么要用 `max`？
    *   因为我们的 `i` 只能向右走，不能回头。
    *   有些字符虽然在哈希表里，但它们可能已经不在当前窗口内了（在 `i` 的左边）。我们要确保 `i` 不会跳回到已经排除的字符位置。

简洁版代码：

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> dic;
        int i = -1, res = 0, len = s.size();
        for(int j = 0; j < len; j++) 
        {
            if (dic.find(s[j]) != dic.end()) // 如果有重复元素，窗口左端点移动到重复元素在之前出现的位置，
                i = max(i, dic.find(s[j])->second);
            dic[s[j]] = j; // 哈希表记录
            res = max(res, j - i); // 更新结果
        }
        return res;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // 哈希表：存储字符到其最后一次出现下标的映射
        unordered_map<char, int> dic;
        
        // i: 当前无重复子串的前一个位置（即左边界，初始化为 -1）
        // res: 记录最大长度
        // len: 字符串总长度
        int i = -1, res = 0, len = s.size();

        for(int j = 0; j < len; j++) 
        {
            // 1. 检查当前字符 s[j] 是否在之前出现过
            if (dic.find(s[j]) != dic.end()) 
            {
                // 如果出现过，尝试更新左边界 i
                // 注意：i 必须是只增不减的，所以用 max
                // 此时 i 跳到了重复字符上一次出现的位置
                i = max(i, dic.find(s[j])->second);
            }

            // 2. 更新（或插入）当前字符的最新下标
            dic[s[j]] = j; 

            // 3. 计算当前窗口长度：j - i
            // 举例：i = -1, j = 0 (第一个字符)，长度 = 0 - (-1) = 1
            // 举例：i = 0, j = 2，代表窗口包含下标 1, 2，长度 = 2 - 0 = 2
            res = max(res, j - i); 
        }

        return res;
    }
};
```

