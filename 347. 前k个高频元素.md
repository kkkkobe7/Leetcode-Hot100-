# 347. 前k个高频元素

解题思路拆解

**1. 统计频率 (Counting)**
*   第一步永远是扫描一遍数组，用 `unordered_map<int, int>` 存储。
*   例如：`[1,1,1,2,2,3]` -> `{1:3, 2:2, 3:1}`。

**2. 建立优先级 (Heapify)**
*   我们需要从这些频率中找到最大的 K 个。
*   **思路选择：**
    *   **全排序：** 把 Map 里的元素按频率排个序，复杂度 $O(N \log N)$。
    *   **大根堆：** 把所有不同的数字放入一个大根堆。建堆复杂度 $O(N)$。

**3. 堆的操作逻辑 (手写堆)**
*   **存储结构：** 使用数组 `p` 模拟完全二叉树。下标 `i` 的左孩子是 `2*i`，右孩子是 `2*i + 1`。
*   **下沉 (Down)：** 如果父节点比孩子节点小，就让它“沉下去”，让大的孩子“浮上来”。这能保证堆顶永远是频率最高的元素。
*   **建堆：** 从最后一个非叶子节点 (`size/2`) 开始向上进行 `down` 操作，可以在 $O(N)$ 时间内完成。

**4. 提取前 K 个**
*   每次把堆顶（最大的数）拿走。
*   为了维持堆的结构，把堆底的元素放到堆顶，然后执行一次 `down` 操作重新调整。
*   重复 $K$ 次。

简洁版代码：

```c++
class Solution {
public:
    static const int N = 1e5 + 10;
    int size = 0;
    pair<int, int> p[N]; // 用树模拟大根堆
    unordered_map<int, int> map;

    void down(int i)
    {
        int u = i; // 记录左右子树中频率更高的节点
        if (i * 2 <= size && p[i * 2].second > p[i].second) u = i * 2;
        if (i * 2 + 1 <= size && p[i * 2 + 1].second > p[u].second) u = 2 * i + 1;
        if (u != i)
        {
            swap(p[i], p[u]);
            down(u);
        }
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        int n = nums.size();
        for (auto& a: nums) map[a] ++;

        for (auto& it: map) p[++ size] = {it.first, it.second};

        for (int i = size/2; i >= 1; i --) down(i);

        vector<int> ans = {};
        for (int i = 1; i <= k; i ++)
        {
            ans.push_back(p[1].first);
            p[1] = p[size --];
            down(1);
        }

        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 定义为 10^5 + 10，足够存储所有不同的数字（因为 nums.length 最大 10^5）
    static const int N = 1e5 + 10;
    int size = 0; // 堆中当前元素的个数
    
    // p[i].first 存数字本身，p[i].second 存该数字出现的频率
    pair<int, int> p[N]; 
    
    // 统计频率的哈希表
    unordered_map<int, int> map;

    // 堆的下沉操作 (维持大根堆性质)
    void down(int i)
    {
        int u = i; // u 最终将指向当前节点及其左右孩子中“频率最大”的那一个
        
        // 如果左孩子存在，且左孩子的频率大于当前节点，更新 u
        if (i * 2 <= size && p[i * 2].second > p[u].second) u = i * 2;
        
        // 如果右孩子存在，且右孩子的频率大于当前节点(或左孩子)，更新 u
        if (i * 2 + 1 <= size && p[i * 2 + 1].second > p[u].second) u = 2 * i + 1;
        
        // 如果最大值不是当前节点，则交换并递归下沉
        if (u != i)
        {
            swap(p[i], p[u]);
            down(u);
        }
    }

    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 1. 统计每个数字出现的频率
        for (auto& a: nums) map[a] ++;

        // 2. 将 Map 中的数据转存到堆数组 p 中（从下标 1 开始）
        size = 0;
        for (auto& it: map) {
            p[++size] = {it.first, it.second};
        }

        // 3. 原地建堆 (Floyd's Build Heap Algorithm)
        // 从最后一个非叶子节点开始下沉，时间复杂度为 O(N)
        for (int i = size / 2; i >= 1; i --) down(i);

        // 4. 依次提取堆顶的前 K 个元素
        vector<int> ans;
        for (int i = 1; i <= k; i ++)
        {
            // 堆顶 (p[1]) 是当前频率最高的
            ans.push_back(p[1].first);
            
            // 将堆底元素换到堆顶，减小堆大小，然后下沉
            p[1] = p[size --];
            down(1);
        }

        return ans;
    }
};
```