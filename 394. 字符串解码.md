# 394. 字符串解码

解题思路拆解 (递归版)

**1. 宏观逻辑：线性扫描 + 遇坑跳跃**
*   我们从左到右扫描字符串。
*   **遇到字母：** 最简单，直接加到当前结果 `ans` 里。
*   **遇到数字：** 计算出倍数 `k`（注意数字可能不止一位，比如 "100[a]"）。
*   **遇到 `[`：** 这是难点。
    *   我们需要找到这个 `[` 对应的那个**匹配的** `]` 在哪里。
    *   找到后，中间这一坨 `[...]` 就是一个子问题。
    *   我们调用递归函数 `decodeString` 专门处理这个子串。
    *   递归返回后，把结果重复 `k` 次，拼接到 `ans` 后面。
    *   **关键点：** 扫描指针 `i` 要直接跳过这一大段，跳到 `]` 的后面继续扫描。

**2. 寻找匹配的 `]`**
*   不能简单地用 `find(']')`，因为里面可能还有嵌套的 `[`。
*   必须使用一个计数器 `cnt`：
    *   遇到 `[`，`cnt++`。
    *   遇到 `]`，`cnt--`。
    *   当 `cnt == 0` 时，说明找到了最外层那个 `[` 对应的 `]`。

简洁版代码：

```c++
class Solution {
public:
    string decodeString(string s) {
        int n = s.size(), k = 0, i = 0; // k记录括号前数字
        string ans = "";

        while (i < n)
        {
            if (s[i] == '[')
            {
                int cnt = 1, j = i + 1; // 记录有多少个"["待匹配，找到当前[匹配的]
                while (cnt)
                {
                    j ++;
                    if (s[j] == '[') cnt ++;
                    else if (s[j] == ']') cnt --;
                }
                string sub = decodeString(s.substr(i + 1, j - i - 1)); // 将这部分作为一个子串
                do ans += sub; while (-- k); // 加上k个sub，并且将k重置

                i = j + 1; // 从']'后一位开始匹配
            }
            else if (s[i] >= '0' && s[i] <= '9')
            {
                k = k * 10 + s[i] - '0';
                i ++;
            }
            else
            {
                ans += s[i];
                i ++;
            }
        }

        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    string decodeString(string s) {
        int n = s.size();
        int k = 0; // 记录倍数 (multiplier)
        int i = 0; // 扫描指针
        string ans = ""; // 当前层级的解码结果

        while (i < n)
        {
            // 情况 1: 遇到 '['，开始处理嵌套子串
            if (s[i] == '[')
            {
                // 1. 寻找匹配的右括号 ']'
                // cnt 初始化为 1，因为当前 i 位置就是第一个 '['
                int cnt = 1; 
                int j = i + 1; // j 从 i 的下一位开始往后找
                
                while (cnt > 0)
                {
                    if (s[j] == '[') cnt ++;      // 遇到嵌套的左括号，计数器 +1
                    else if (s[j] == ']') cnt --; // 遇到右括号，计数器 -1
                    
                    // 只有当 cnt 还没减到 0 时，j 还要继续往后移
                    // (注意：这里有一个小细节，当 cnt 变为 0 时，j 刚好停在匹配的 ']' 上)
                    if (cnt > 0) j++; 
                }
                
                // 2. 递归处理子串
                // substr(start, length)
                // start = i + 1 (跳过当前的 '[')
                // length = j - (i + 1) (不包含当前的 ']')
                string sub = decodeString(s.substr(i + 1, j - i - 1)); 
                
                // 3. 将递归结果重复 k 次加入当前 ans
                // 您的 do-while 写法虽然能跑，但如果 k=0 (虽然题目保证k是正数) 可能会出问题
                // 建议使用 while(k--)
                while (k > 0) {
                    ans += sub;
                    k--;
                }
                
                // 【重要】k 必须重置，否则会影响后面的数字解析
                // (虽然 while(k--) 已经把 k 减为 0 了，但显式重置是个好习惯)
                k = 0; 

                // 4. 指针跳跃
                // i 直接跳到匹配的 ']' 后面一位，继续处理剩下的字符串
                i = j + 1; 
            }
            // 情况 2: 遇到数字，计算倍数 k
            else if (s[i] >= '0' && s[i] <= '9')
            {
                // 处理多位数字的情况 (例如 "100[a]")
                k = k * 10 + (s[i] - '0');
                i ++;
            }
            // 情况 3: 遇到普通字母
            else
            {
                ans += s[i];
                i ++;
            }
        }

        return ans;
    }
};
```

