# 406. 根据身高重建队伍

### 1. 从低到高排

解题思路拆解 (空位填充法)

**1. 逆向思维：谁的位置最好确定？**

*   这道题最难的地方在于：每个人的位置取决于“比他高或一样高”的人。
*   **思考：** 如果我们按照**身高从小到大**处理，会发生什么？
    *   当我们安排最矮的人时，对于比他高的人，他**完全不可见**（因为题目只关心“>=”的数量）。
    *   也就是说，**矮个子坐在哪里，对于高个子的 `k` 值计算没有影响**。
    *   反过来：**高个子坐在哪里，对矮个子是有影响的**（因为高个子 >= 矮个子）。

**2. 核心逻辑**
*   **排序规则：**
    *   身高：**从小到大**。
    *   如果身高一样：**K 值从大到小**（这一步是关键，稍后解释）。
*   **填空逻辑：**
    *   假设现在轮到处理一个人 `[h, k]`。
    *   因为他是目前还没排队的人里**最矮**的，所以比他高的人（还没入队）将来肯定会占住某些坑位，并且会被统计进这个人的 `k` 里吗？
    *   **不对！逻辑反了！**
    *   让我们修正一下：
        *   当前这个人 `[h, k]`，意味着在他前面必须有 `k` 个**比他高或相等**的人。
        *   可是我们是**从小到大**排序的，所以已经入队的人（ans 里填好的）都**比他矮**。
        *   比他矮的人，是不配被计入他的 `k` 值的！
        *   所以，他的 `k` 值，是留给**未来**那些**比他高**的人的。
        *   这意味着：**在他前面，必须预留出 `k` 个空位**。这些空位将来会被比他高的人填满。

**3. 为什么身高相同时 K 要从大到小？**
*   假设有 `[4, 4]` 和 `[4, 6]`。
*   如果我们先放 `[4, 4]`，它前面留 4 个空位。
*   如果我们先放 `[4, 6]`，它前面留 6 个空位。
*   因为它们身高相同，互相之间也是“>=”的关系。
*   如果先处理 K 小的，后处理 K 大的，K 大的在找空位时，会把 K 小的那个当作“空位”吗？**不会**，因为 K 小的已经填进去了。但根据题意，同身高应该算进去。
*   排序规则 `return a[0] == b[0]? a[1] > b[1]: a[0] < b[0];`同身高，先处理 `k` 大的，把它放得靠后一点；然后再处理 `k` 小的，因为 `k` 小的在前面，对于 `k` 大的来说，前面的位置已经被占了（且身高相同，符合条件）。

简洁版代码：

```c++
class Solution {
public:
    /*
    对于身高相同的人来说，k越低越靠前
    对于k相同的人来说，身高越低越靠前

    对于最矮的人i来说，应该排在第k_i位
    对于第二矮的人j来说，应该在空余位置中排在k_j位
    */

    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        return a[0] == b[0]? a[1] > b[1]: a[0] < b[0]; // 注意好排序的位置
    }

    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);

        int n = people.size();
        vector<vector<int>> ans(n);
        for (auto& p: people)
        {
            int pos = p[1] + 1;
            for (int i = 0; i < n; i ++)
            {
                if (ans[i].empty())
                {
                    pos --;
                    if (pos == 0)
                    {
                        ans[i] = p;
                        break;
                    }
                }
            }
        }

        return ans;
    }
};
```



注释版代码：

```c++
class Solution {
public:
    // 排序比较器
    // 1. 身高 (a[0]) 从小到大排序
    // 2. 如果身高相同，K 值 (a[1]) 从大到小排序
    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0]; 
    }

    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        // 1. 排序
        sort(people.begin(), people.end(), cmp);

        int n = people.size();
        // 初始化结果数组，一开始所有位置都是空的
        // 我们可以把 empty() 作为判断位置是否为空的依据
        vector<vector<int>> ans(n);

        // 2. 遍历每个人，把他们放到合适的“空位”上
        for (auto& p: people)
        {
            // 这个人要求前面有 p[1] 个 >= 他身高的人
            // 因为我们是从矮到高处理的，已入队的人都比他矮 (忽略同身高特殊处理)
            // 所以，我们需要给他预留出 p[1] 个空位，这些空位将来是留给高个子的
            // 他自己应该坐在 第 p[1] + 1 个空位 上
            int pos = p[1] + 1;
            
            // 遍历结果数组，寻找第 pos 个空位
            for (int i = 0; i < n; i ++)
            {
                // 如果当前位置是空的
                if (ans[i].empty())
                {
                    pos --; // 消耗一个空位额度
                    
                    // 如果 pos 减到了 0，说明这就是我们要找的第 p[1]+1 个空位
                    if (pos == 0)
                    {
                        ans[i] = p; // 让这个人坐下
                        break;      // 处理下一个人
                    }
                }
            }
        }

        return ans;
    }
};
```

### 2. 从高到低排序

核心逻辑：看不见的“矮个子”

1.  **高个子的特权**：
    *   如果我们先让高个子排好队。
    *   当一个**矮个子**插队插到高个子前面时，**高个子是“看不见”这个矮个子的**。
    *   因为题目统计的是 `k` (前面身高 $\ge$ 自己的人数)。矮个子不会让高个子的 `k` 值发生变化。
    *   **结论**：我们可以放心大胆地把矮个子插到任意位置，而不用担心破坏已经排好的高个子的 `k` 属性。

2.  **排序规则**：
    *   **身高 `h`**：从大到小排序（先处理高个子）。
    *   **K 值 `k`**：如果身高相同，`k` 从小到大排序（先处理靠前的）。

3.  **插入逻辑**：
    *   排完序后，每个人手中的 `k`，其实就是他应该**插入到当前队列的索引位置**。
    *   比如 `[5, 2]`，意思是：在当前已经排好的（全都是比他高或一样高的）队伍里，他要坐在 index = 2 的位置上。

---

### 举例演示

输入：`[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`

**1. 排序**
*   按 `h` 降序，`k` 升序：
*   `[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]`

**2. 依次插入**
*   **第 1 步**：处理 `[7,0]`。插入到 index `0`。
    *   队列：`[[7,0]]`
*   **第 2 步**：处理 `[7,1]`。插入到 index `1`。
    *   队列：`[[7,0], [7,1]]`
*   **第 3 步**：处理 `[6,1]`。插入到 index `1`（插队！原 index 1 的 `[7,1]` 被挤到后面）。
    *   队列：`[[7,0], [6,1], [7,1]]`
    *   *解释：[6,1] 前面有 [7,0] 一个比他高，符合 k=1。而 [7,1] 依然只看到 [7,0] 比他高，看不见 [6,1]，所以也符合。*
*   **第 4 步**：处理 `[5,0]`。插入到 index `0`。
    *   队列：`[[5,0], [7,0], [6,1], [7,1]]`
*   **第 5 步**：处理 `[5,2]`。插入到 index `2`。
    *   队列：`[[5,0], [7,0], [5,2], [6,1], [7,1]]`
*   **第 6 步**：处理 `[4,4]`。插入到 index `4`。
    *   队列：`[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]`

注释版代码：

```c++
class Solution {
public:
    // 排序规则：
    // 1. 身高 (h) 从大到小
    // 2. 如果身高相同，K 值 (k) 从小到大
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1]; // 同高，k小的在前
        return a[0] > b[0]; // 高个子在前
    }

    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        // 1. 排序
        sort(people.begin(), people.end(), cmp);

        // 2. 插队
        vector<vector<int>> ans;
        for (auto& p : people) {
            // p[1] 就是这个人的 k 值，也就是他应该插入的索引位置
            // begin() + p[1] 表示在第 p[1] 个位置之前插入
            ans.insert(ans.begin() + p[1], p);
        }
        
        return ans;
    }
};
```

