# 148. 排序链表

### 解题思路拆解

**1. 宏观策略：分治法 (Divide and Conquer)**
归并排序的核心思想只有三步：

- **分 (Divide)：** 把长链表从中间切断，分成两半。
- **治 (Conquer)：** 递归地对左半边和右半边分别进行排序。
- **合 (Merge)：** 把两个排好序的短链表，合并成一个有序的长链表。

**2. 难点一：如何找到中点并切断？**

- **找中点：** 使用 **快慢指针 (Slow/Fast Pointers)**。快指针一次走两步，慢指针一次走一步。当快指针走到终点时，慢指针刚好走到中间。
- **切断：** 这一点很容易被忽略。我们需要一个额外的指针（代码中的 la 或 prev）紧跟在慢指针后面。当慢指针找到中点后，我们要把 la->next 设为 nullptr，这样链表才算真正断开成两条。

**3. 难点二：如何合并？**

- 这是一个经典的子问题：**[LeetCode 21] 合并两个有序链表**。
- 我们需要一个哨兵节点（Dummy Node）或者临时指针来串联两个链表中的节点，谁小就串谁。

**4. 递归终止条件**

- 当链表为空，或者链表只有一个节点时，就不需要切分了，直接返回。



简洁版代码：

```c++
class Solution {
public:
    ListNode* merge(ListNode* a, ListNode* b)
    {
        ListNode *ans = new ListNode();
        ListNode *p = a, *q = b;
        while (p && q)
        {
            if (p->val <= q->val) 
            {
                ans->next = p;
                p = p->next;
            }
            else
            {
                ans->next = q;
                q = q->next;
            }
            ans = ans->next;
        }
        if (p) ans->next = p;
        if (q) ans->next = q;
        return a->val <= b->val? a: b;
    }

    ListNode* sortList(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return head;

        ListNode *slow = head, *fast = head, *la = head; // 找到中间的节点，一分而二
        while (fast && fast->next)
        {
            la = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        
        la->next = nullptr; // 一分为二
        ListNode* l = sortList(head);
        ListNode* r = sortList(slow);

        return merge(l, r);
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // ------------------------------------------------
    // 辅函数：合并两个有序链表 (a 和 b)
    // ------------------------------------------------
    ListNode* merge(ListNode* a, ListNode* b)
    {
        // 创建一个哨兵节点（Dummy Node），用来充当合并后链表的临时头
        // 注意：这里 new 出来如果没有 delete 会有内存泄漏，面试时最好提一句
        ListNode *ans = new ListNode();
        
        // p 和 q 分别遍历两个链表
        ListNode *p = a, *q = b;
        
        // ans 指针这里实际上充当的是 tail（尾指针），始终指向当前合并链表的最后一个节点
        // 为了复用 ans 变量，原代码这里让 ans 指向了 dummy，后面会移动
        ListNode *tail = ans; 

        while (p && q)
        {
            if (p->val <= q->val) 
            {
                tail->next = p; // 谁小就把谁接在后面
                p = p->next;
            }
            else
            {
                tail->next = q;
                q = q->next;
            }
            tail = tail->next; // 尾指针后移
        }
        
        // 把剩余没走完的链表直接接上
        if (p) tail->next = p;
        if (q) tail->next = q;
        
        // 返回逻辑：
        // 虽然有 dummy 节点，但您这里直接判断了 a 和 b 的大小来返回头节点
        // 因为 a 和 b 是原来的头，合并后的新头肯定是它俩中较小的那个
        // 这种写法前提是 a 和 b 都不为空（由 sortList 的 base case 保证了）
        return a->val <= b->val ? a : b;
        
        // 标准写法通常是返回哨兵的下一个：
        // return ans->next; 
    }

    // ------------------------------------------------
    // 主函数：归并排序
    // ------------------------------------------------
    ListNode* sortList(ListNode* head) {
        // 1. 递归终止条件 (Base Case)
        // 如果链表为空或只有一个节点，说明已经有序，直接返回
        if (head == nullptr || head->next == nullptr) return head;

        // 2. 找中点 (快慢指针)
        // slow: 慢指针，最后指向中点
        // fast: 快指针，用于探路
        // la (last of a): 用于记录 slow 的前一个节点，为了切断链表
        ListNode *slow = head, *fast = head, *la = head; 
        
        while (fast && fast->next)
        {
            la = slow;              // la 紧跟在 slow 后面
            slow = slow->next;      // slow 走一步
            fast = fast->next->next;// fast 走两步
        }
        
        // 3. 切断链表 (Cut)
        // 此时 slow 位于中点，我们把 la->next 置空，将链表一分为二
        // 左半边：head ... la
        // 右半边：slow ... end
        la->next = nullptr; 

        // 4. 递归排序 (Divide)
        ListNode* l = sortList(head); // 排序左半边
        ListNode* r = sortList(slow); // 排序右半边

        // 5. 合并结果 (Merge)
        return merge(l, r);
    }
};
```

