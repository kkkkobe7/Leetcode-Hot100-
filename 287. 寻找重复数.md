# 287. 寻找重复数

解题思路拆解

**1. 抽象建模：数组即链表**
*   我们可以把数组想象成一个有向图（或链表）：对于位置 `i`，它指向的下一个位置是 `nums[i]`。
*   **举例**：`nums = [1, 3, 4, 2, 2]`
    *   `0 -> 1`
    *   `1 -> 3`
    *   `3 -> 2`
    *   `2 -> 4`
    *   `4 -> 2` (这里出现了环！)
*   **核心发现**：如果有重复的数字，说明有两个不同的下标指向了同一个值。在图论中，这等同于**两个节点指向了同一个节点**，必然会导致**环**的产生。

**2. 重复的数 = 环的入口**
*   因为数组里的数都在 `1` 到 `n` 之间，而下标是 `0` 到 `n`。
*   由于没有数字指向下标 `0`，所以 `0` 一定是“链表”的起点。
*   如果我们从 `0` 开始出发，一旦进入了环，那个**环的入口节点**所对应的数字，就是那个被多个下标指向的**重复数字**。

**3. 算法流程 (快慢指针)**
*   **第一阶段（相遇）**：
    *   `slow` 走一步 (`slow = nums[slow]`)。
    *   `fast` 走两步 (`fast = nums[nums[fast]]`)。
    *   当它们在环内某处相遇时停止。
*   **第二阶段（找入口）**：
    *   将 `fast` 重置到起点 `0`。
    *   `slow` 和 `fast` 现在都一次只走一步。
    *   它们再次相遇的地方，就是环的入口，即重复的数。

可能会思考slow和fast万一开头就在自环中迷路，实际上由于数组下标从0开始，但数字从1开始，所以不可能从开头位置出现自环。那其他位置的自环呢？比如示例2，下标1的位置为1，这个自环不会出现在重复数组存在的那条链表中（否则就有两个环）

简洁版代码：

```c++
class Solution {
public:
    // 如果将每一个位置视作一个链表，即节点i指向nums[i]，如果有重复元素，就会有重复的不同位置的节点指向同一个位置
    // 如果没有重复节点，那么应该是一条或者多条完整的链表；如果有重复节点，一定存在非自环的环，类比于找链表环形入口
    int findDuplicate(vector<int>& nums) {
        int slow = nums[0], fast = nums[nums[0]];
        while (slow != fast)
        {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        fast = 0;
        while (slow != fast)
        {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        // 这里的 nums[i] 就相当于链表中的 next 指针
        
        // 1. 第一阶段：快慢指针找相遇点
        // 起点设为 nums[0] 而不是 0，是为了防止循环一开始就因为 slow == fast 而停止
        int slow = nums[0];
        int fast = nums[nums[0]];
        
        while (slow != fast)
        {
            slow = nums[slow];       // 慢指针走一步
            fast = nums[nums[fast]]; // 快指针走两步
        }
        
        // 2. 第二阶段：寻找环的入口 (重复的数字)
        // 将 fast 重新放回起点 0
        fast = 0;
        
        // 两个指针都一次走一步，直到再次相遇
        while (slow != fast)
        {
            slow = nums[slow];
            fast = nums[fast];
        }
        
        // 再次相遇的点即为重复数字
        return slow;
    }
};
```

