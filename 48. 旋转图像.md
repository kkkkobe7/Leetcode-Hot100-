# 48. 旋转图像

解题思路拆解

**1. 核心数学规律**
对于一个 $n \times n$ 的矩阵，点 $(i, j)$ 顺时针旋转 90 度后，它的新位置是 $(j, n-1-i)$。

**2. 寻找“四位一体”的循环**
如果我们直接把 $(i, j)$ 移动到新位置，那新位置原来的数就会被覆盖。为了避免数据丢失，我们需要观察一个完整的旋转循环。
一个点经过连续四次旋转会回到原点，这四个点形成了一个闭环：
1.  第一个点：$(i, j)$
2.  第二个点：$(j, n-1-i)$
3.  第三个点：$(n-1-i, n-1-j)$
4.  第四个点：$(n-1-j, i)$

**结论：** 我们只要用一个临时变量 `tmp` 暂存其中一个点，就可以同时完成这四个位置的交换。

**3. 遍历区域的选择（难点）**
我们只需要遍历矩阵的 **1/4 区域** 即可旋转整个矩阵。
*   如果 $n$ 是偶数，我们将矩阵分为四个相等的正方形（大小为 $n/2 \times n/2$）。
*   如果 $n$ 是奇数，中心点不动，我们将矩阵分为四个矩形区域（大小为 $(n+1)/2 \times n/2$），确保覆盖到除中心点外所有的点。

简洁版代码：

```c++
class Solution {
public:
    // 每四个为一组
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int n2 = n / 2, n1 = n2 + n % 2; // 按照四个一组，遍历位于第一象限的点（考虑奇偶）
        for (int i = 0; i < n1; i ++)
        {
            for (int j = 0; j < n2; j ++)
            {
                // [a][b] <-> [c][a]    b + c = n - 1
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = tmp;
            }
        }

        return ;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 顺时针旋转 90 度：原地操作
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        
        // n1 和 n2 定义了我们需要遍历的“起始区域”
        // 这个区域大约是矩阵的 1/4
        int n2 = n / 2;           // 纵向遍历一半
        int n1 = n2 + n % 2;      // 横向遍历一半（如果是奇数，多包含一行/列）

        for (int i = 0; i < n1; i ++)
        {
            for (int j = 0; j < n2; j ++)
            {
                // 暂存第一个点
                int tmp = matrix[i][j];
                
                // 进行四路赋值。注意赋值的顺序是逆向的，这样可以保证数据不被提前覆盖
                // 规律：每一位的值都来自它旋转前的“前任”位置
                
                // 1. 左下角 -> 左上角
                matrix[i][j] = matrix[n - 1 - j][i];
                
                // 2. 右下角 -> 左下角
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                
                // 3. 右上角 -> 右下角
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                
                // 4. 左上角(暂存在tmp) -> 右上角
                matrix[j][n - 1 - i] = tmp;
            }
        }
    }
};
```

