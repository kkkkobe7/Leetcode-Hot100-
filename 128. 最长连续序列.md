# 128. 最长连续序列

### 解题思路拆解

**1. 核心直觉：如何避免** `O(N^2)`

- 我们把所有数字扔进哈希集合（Set）里，方便快速查找。
- 如果我们对数组里的每个数 x，都去尝试数数 x, x+1, x+2...，那么最坏情况下（比如数组本身就是 1, 2, 3... n），复杂度会退化成 `O(N^2)`。
- **关键优化：只从“头”开始数！**

**2. 寻找“序列的头”**

- 对于数字 x，如果集合里存在 x-1，说明 x 肯定不是这一串连续序列的**开头**（x-1 才是更前面的）。
- 既然 x 不是开头，那就完全没必要从 x 开始数，直接跳过。
- 只有当集合里**找不到** x-1 时，我们才确信 x 是一个新序列的起点，这时候才启动 while 循环往后数。

**3. 复杂度分析**

- 尽管里面有个 while 循环，但因为那个 if (set.contains(a - 1)) 的存在，**每个数字最多只会被 while 循环访问一次**。
- 外层循环遍历一次，内层 while 总共加起来也只遍历一次。
- 总复杂度是 `O(N)`。



简洁版代码：

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> set(nums.begin(), nums.end());
        int ans = 0, n = nums.size();
        for (auto& a: nums)
        {
            if (set.contains(a - 1)) continue; // 判断是否在是一个序列的开头（避免重复）
            int len = 1;
            while (set.contains(a + len)) len ++; // 遍历长度
            ans = max(ans, len);
            if (ans * 2 >= n) break; // 找到超过一半长度的话，一定是最长的了
        }

        return ans;
    }
};
```



注释版代码：

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        // 1. 数据预处理
        // 将所有数字放入哈希集合，实现 O(1) 查找
        // 同时利用 Set 的去重特性，方便处理重复元素
        unordered_set<int> set(nums.begin(), nums.end());
        
        int ans = 0;
        int n = nums.size(); // 注意：这里的 n 是原数组长度，包含重复元素
        
        // 2. 遍历每一个数字
        for (auto& a: nums)
        {
            // 3. 核心剪枝 (寻找序列起点)
            // 如果集合中存在 a-1，说明 a 肯定不是连续序列的起点
            // (比如有 3 和 4，遇到 4 时发现有 3，那 4 就不用数了，等遍历到 3 的时候自然会数到 4)
            // 直接跳过，保证时间复杂度控制在 O(N)
            if (set.contains(a - 1)) continue; 
            
            // 4. 从起点开始向后计数
            int len = 1;
            // 不断检查 a+1, a+2... 是否存在
            while (set.contains(a + len)) {
                len ++; 
            }
            
            // 更新最大长度
            ans = max(ans, len);
            
            // 5. 额外的小优化 (Optional)
            // 如果找到的序列长度已经超过了数组总数的一半
            // 那么剩下的元素加起来也不可能凑出更长的序列了，可以直接返回
            // 注意：因为 set 去重了，这里的 n 最好是用 set.size() 来判断更严谨
            // 不过用原数组 size 判断也是安全的（只会少剪枝，不会错）
            if (ans > n / 2) break; 
        }

        return ans;
    }
};
```

