# 300. 最长递增子序列

解题思路拆解

**1. 核心直觉：贪心思想**
*   如果我们要让递增子序列尽可能长，我们需要让序列上升得越“慢”越好。
*   **举例**：如果序列结尾是 `10`，后面来个 `5`，我们显然更希望结尾是 `5`，因为 `5` 后面能接的数字比 `10` 多。
*   **结论**：在子序列长度相同的情况下，我们应该保留那个**结尾数字最小**的子序列。

**2. 定义状态数组 `dp`**
*   这里的 `dp[i]` 并不表示“以 $i$ 结尾的长度”，而是表示：**长度为 $i$ 的上升子序列中，最小的结尾数字。**
*   **特性**：`dp` 数组一定是**严格递增**的。因为长度为 5 的序列结尾一定比长度为 4 的序列结尾大。

**3. 维护过程（二分查找）**
当我们遍历数组中的每一个数 `a` 时：
*   **如果 `a` 比 `dp` 数组里所有的结尾数字都大**：说明 `a` 可以接在当前最长序列的后面，形成一个更长的序列。
*   **如果 `a` 不比所有的都大**：说明 `a` 可以“优化”某个长度的序列。我们在 `dp` 数组中找到**第一个大于等于 `a` 的位置**，把那个位置的数字换成 `a`。
    *   由于 `dp` 数组是有序的，找这个位置可以使用 **二分查找** (`std::lower_bound`)。

简洁版代码：

```
class Solution {
public:
    vector<int> dp;
    // dp[i]表示长度为i的严格递增子序列结尾数字为dp[i]，该数组一定是递增数组
    int lengthOfLIS(vector<int>& nums) {
        dp.push_back(-1e4-10);
        for (auto& a: nums)
        {
            int i = lower_bound(dp.begin(), dp.end(), a) - dp.begin();
            if (i == dp.size()) dp.push_back(a);
            else dp[i] = a;
        }

        return dp.size() - 1;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // dp 数组：dp[i] 存储长度为 i 的递增子序列的最小结尾数字
    vector<int> dp;

    int lengthOfLIS(vector<int>& nums) {
        if (nums.empty()) return 0;

        // 初始化：放入一个极小值作为哨兵（占位符）
        // 这样可以确保任何 nums 中的数字都能正确处理
        // 注意：dp[0] 只是个辅助位，不计入最终长度
        dp.push_back(-1e4 - 10); 

        for (auto& a : nums)
        {
            // 1. 使用二分查找寻找第一个大于等于 a 的数字位置
            // lower_bound 返回的是一个迭代器
            auto it = lower_bound(dp.begin(), dp.end(), a);
            int i = it - dp.begin();

            // 2. 如果 a 比当前 dp 里的所有结尾都大
            // lower_bound 会指向 dp.end()
            if (it == dp.end()) {
                dp.push_back(a); // 发现了更长的子序列，长度 +1
            } 
            // 3. 否则，用 a 更新这个位置
            // 贪心策略：把结尾数字变小，为后续增长留出空间
            else {
                dp[i] = a;
            }
        }

        // 最终 dp 数组的长度减去初始放入的哨兵，即为最长递增子序列的长度
        return dp.size() - 1;
    }
};
```