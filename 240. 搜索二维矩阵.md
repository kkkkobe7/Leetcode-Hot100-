# 240. 搜索二维矩阵

解题思路拆解

**1. 寻找“分叉路口” (BST 思想)**
*   如果我们从左上角 `(0,0)` 开始找：往右是变大，往下也是变大。如果 `target` 比当前值大，我们不知道该往哪走。
*   如果我们从右上角 `(0, m-1)` 开始找：
    *   往**左**走，数字会**变小**。
    *   往**下**走，数字会**变大**。
*   **这就形成了一个天然的二叉搜索树（BST）结构！** 右上角的点就是“根节点”，左边的子树都比它小，下边的子树都比它大。

**2. 搜索逻辑 (Z字形搜索)**
站在右上角 `(i, j)`，将当前值 `matrix[i][j]` 与 `target` 比较：
*   **匹配：** 找到了，返回 `true`。
*   **当前值 < target：** 说明这一行左边的所有数字都比 `target` 小（因为行是递增的）。这一行没意义了，**向下移一行** (`i++`)。
*   **当前值 > target：** 说明这一列下边的所有数字都比 `target` 大（因为列是递增的）。这一列没意义了，**向左移一列** (`j--`)。

**3. 为什么是高效的？**
*   每一次比较，我们都能直接**排除掉整整一行或一列**。
*   最坏的情况下，我们也只是从右上角走到左下角，总共步数是 $n + m$ 步。

简洁版代码：

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size(), m = matrix[0].size();
        int i = 0, j = m - 1;
        while (i < n && j >= 0)
        {
            if (matrix[i][j] < target) i ++;
            else if (matrix[i][j] > target) j --;
            else return true;
        }

        return false;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // n: 行数, m: 列数
        int n = matrix.size(), m = matrix[0].size();
        
        // 1. 初始化起点：右上角 (第 0 行，最后一列)
        int i = 0, j = m - 1;
        
        // 2. 循环条件：只要还在矩阵范围内
        while (i < n && j >= 0)
        {
            // 情况 A：当前值太小了
            // 说明 target 只可能在当前位置的下方，直接排除当前行
            if (matrix[i][j] < target) {
                i ++; 
            }
            // 情况 B：当前值太大了
            // 说明 target 只可能在当前位置的左侧，直接排除当前列
            else if (matrix[i][j] > target) {
                j --; 
            }
            // 情况 C：找到了
            else {
                return true;
            }
        }

        // 走到边界还没找到，说明矩阵中不存在 target
        return false;
    }
};
```

