# 34. 在排序数组中查找元素的第一个和最后一个位置

 解题思路拆解

**1. 核心矛盾：如何通过二分找“范围”？**
*   标准的二分查找通常在找到目标值时就直接返回了。
*   但在本题中，目标值可能重复出现（如 `[8, 8, 8]`），我们需要的是这个“块”的**最左端**和**最右端**。

**2. 统一二分模型：蓝红划分法（区间排除法）**
代码中采用了一种非常稳健的二分写法：设定 `l = -1, r = n`。
*   这相当于在数组两端加了两个虚拟哨兵。
*   `while (l + 1 != r)` 保证了循环结束时，`l` 和 `r` 刚好指向边界两侧的两个元素。

**3. 两次搜索的不同逻辑**
*   **寻找左边界 (`search1`)**：
    *   我们要找的是**第一个 $\ge$ target** 的位置。
    *   条件设定：如果 `nums[mid] < target`，说明目标还在右边，移动左边界 `l`。
    *   结果：循环结束时，`r` 是第一个满足 $\ge target$ 的下标。
*   **寻找右边界 (`search2`)**：
    *   我们要找的是**最后一个 $\le$ target** 的位置。
    *   条件设定：如果 `nums[mid] <= target`，即使等于目标也要继续往右看，移动左边界 `l`。
    *   结果：循环结束时，`l` 是最后一个满足 $\le target$ 的下标。

**4. 结果校验**
*   二分查找结束后，必须检查找到的下标是否合法，且对应的值是否真的等于 `target`。

简洁版：

```c++
class Solution {
public:
    int search1(vector<int>& nums, int target)
    {
        int l = -1, r = nums.size(); // 假设总共n个元素
        while (l+1 != r)
        {
            int mid = l + r >> 1;
            if (nums[mid] < target) l = mid;
            else r = mid;
        }
        return r;
    }

    int search2(vector<int>& nums, int target)
    {
        int l = -1, r = nums.size(); // 假设总共n个元素
        while (l+1 != r)
        {
            int mid = l + r >> 1;
            if (nums[mid] <= target) l = mid;
            else r = mid;
        }
        return l;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.size() == 0) return {-1, -1};
        int l = search1(nums, target);
        if (l >= nums.size() || nums[l] != target) return {-1, -1};
        return {search1(nums, target), search2(nums, target)};
    }
};
```

注释版：

```c++
class Solution {
public:
    // search1: 寻找第一个大于或等于 target 的元素下标
    int search1(vector<int>& nums, int target)
    {
        // 设定 l 为“确定小于 target 的区间”右端
        // 设定 r 为“确定大于等于 target 的区间”左端
        int l = -1, r = nums.size(); 
        while (l + 1 != r) // 当 l 和 r 之间还有元素时循环
        {
            int mid = l + (r - l) / 2; // 防止 l+r 过大导致溢出
            if (nums[mid] < target) 
                l = mid; // 蓝色区域：确定小于 target，移动左界
            else 
                r = mid; // 红色区域：可能大于等于 target，移动右界
        }
        // 循环结束时 l + 1 == r，r 指向第一个 >= target 的位置
        return r; 
    }

    // search2: 寻找最后一个小于或等于 target 的元素下标
    int search2(vector<int>& nums, int target)
    {
        int l = -1, r = nums.size();
        while (l + 1 != r)
        {
            int mid = l + (r - l) / 2;
            if (nums[mid] <= target) 
                l = mid; // 蓝色区域：确定小于等于 target，移动左界
            else 
                r = mid; // 红色区域：确定大于 target，移动右界
        }
        // 循环结束时 l + 1 == r，l 指向最后一个 <= target 的位置
        return l;
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        // 1. 空数组特判
        if (nums.empty()) return {-1, -1};

        // 2. 查找左边界
        int first = search1(nums, target);

        // 3. 校验左边界：
        // 如果 first 越界，或者找到的值不是 target，说明 target 不存在
        if (first == nums.size() || nums[first] != target) {
            return {-1, -1};
        }

        // 4. 查找右边界并返回
        // 此时已知 target 存在，直接调用 search2
        return {first, search2(nums, target)};
    }
};
```



内置函数版：

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.size() == 0) return {-1, -1};
        int l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
        int r = upper_bound(nums.begin(), nums.end(), target) - nums.begin() - 1;
        if (l < 0 || l >= nums.size() || nums[l] != target) l = -1;
        if (r < 0 || r >= nums.size() || nums[r] != target) r = -1;
        return {l, r};
    }
};
```

