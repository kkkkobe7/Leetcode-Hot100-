# 438. 找到字符串中所有字母异位词

解题思路拆解

**1. 核心定义：什么是异位词？**
*   两个字符串长度相同，且每个字符出现的次数也相同。
*   这就暗示我们需要维护一个固定长度为 `p.len` 的**窗口**。

**2. 朴素思路 vs 优化思路**
*   **朴素法：** 滑动窗口，每动一步，就截取子串，统计词频，跟 `p` 的词频对比。对比一次需要 $O(26)$。总复杂度 $O(26N)$。
*   **优化法：**
    *   我们维护一个 `cur` 数组，初始记录 `p` 的词频（正数表示“欠”多少，负数表示“多”多少，0 表示“刚好”）。
    *   我们维护一个 `cnt` 变量，记录**当前有多少种字母的数量是不对劲的（即 `cur[i] != 0`）**。
    *   当窗口滑动时，只更新进来的字母和出去的字母。
    *   如果 `cnt == 0`，说明所有字母的欠债和盈余都清零了，找到一个异位词。

**3. 状态转移细节**
*   **入窗（右边进来）：** 字符 `x` 进来，我们需要更少的 `x` 了（`cur[x]--`）。
    *   如果 `cur[x]` 变成了 0，说明刚才缺一个或者多一个，现在刚好平了，不匹配数 `cnt` 减 1。
    *   如果 `cur[x]` 变成了 -1，说明刚才刚好，现在多了一个，不匹配数 `cnt` 加 1。
*   **出窗（左边出去）：** 字符 `y` 出去，我们需要更多的 `y` 了（`cur[y]++`）。
    *   如果 `cur[y]` 变成了 0，说明刚才多一个或缺一个，现在平了，`cnt` 减 1。
    *   如果 `cur[y]` 变成了 1，说明刚才刚好，现在缺了一个，`cnt` 加 1。

简洁版代码：

```c++
class Solution {
public:
    static const int N = 26;
    int cur[N];

    vector<int> findAnagrams(string s, string p) {
        int len = p.size(), n = s.size(), differ = 0;
        if (len > n) return {};

        for (auto& c: p) cur[c-'a'] ++;
        for (int i = 0; i < 26; i ++) if (cur[i] != 0) differ ++;

        vector<int> ans;
        int cnt = differ, k = 0; // cnt为待匹配字符种类数（只有当每一类字符待匹配数为0的时候，cnt--），k为当前窗口内元素数量
        for (int i = 0; i < n; i ++)
        {
            int id = s[i] - 'a'; // 当前字母下标

            // 开始进行匹配
            k ++;
            if (k > len) // 若窗口内元素数量已满，将窗口最左侧元素去除
            {
                int left = s[i - len] - 'a'; // 左侧下标
                cur[left] ++;
                if (cur[left] == 0) cnt --;
                else if (cur[left] == 1) cnt ++; 
                k --;
            }

            cur[id] --;
            if (cur[id] == 0) cnt --; // 有效消除
            else if (cur[id] == -1) cnt ++;

            if (k == len && cnt == 0) ans.push_back(i - len + 1);
            
        }

        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    static const int N = 26;
    // cur[i] 的含义：
    // > 0 : 窗口内该字符还不够，还需要 cur[i] 个
    // = 0 : 窗口内该字符数量刚刚好
    // < 0 : 窗口内该字符太多了，多了 abs(cur[i]) 个
    int cur[N];

    vector<int> findAnagrams(string s, string p) {
        int len = p.size(), n = s.size(), differ = 0;
        
        // 特判：如果 s 比 p 还短，不可能包含 p 的异位词
        if (len > n) return {};

        // 1. 初始化
        // 统计 p 中字符的需求量
        for (auto& c: p) cur[c-'a'] ++;
        
        // differ (也就是代码中的 cnt) 记录有多少类字符的数量不匹配
        // 初始时，只要 p 中有的字符，对于空的窗口来说都是“不匹配”的
        for (int i = 0; i < 26; i ++) if (cur[i] != 0) differ ++;

        vector<int> ans;
        int cnt = differ; // cnt: 当前窗口内有多少种字符不满足要求 (cur[i] != 0)
        int k = 0;        // k: 当前窗口的大小
        
        // 2. 滑动窗口开始
        for (int i = 0; i < n; i ++)
        {
            int id = s[i] - 'a'; // 当前进入窗口的字符

            // ---------------------------------------------------
            // A. 进窗逻辑 (Right In)
            // ---------------------------------------------------
            k ++; // 窗口变大
            
            // 每次进来一个字符，需求量就减少 (或者盈余量增加)
            cur[id] --; 
            
            // 检查 cnt 变化：
            // 如果变成 0，说明刚才可能是 1 (缺一个)，现在补齐了 -> 不匹配数减 1
            if (cur[id] == 0) cnt --; 
            // 如果变成 -1，说明刚才可能是 0 (刚好)，现在多了一个 -> 不匹配数加 1
            else if (cur[id] == -1) cnt ++;

            // ---------------------------------------------------
            // B. 出窗逻辑 (Left Out)
            // ---------------------------------------------------
            // 维护固定窗口大小 len
            if (k > len) 
            {
                int left = s[i - len] - 'a'; // 要移出窗口的左侧字符
                
                // 移出窗口，意味着需求量增加 (或者盈余量减少)
                cur[left] ++;
                
                // 检查 cnt 变化：
                // 如果变成 0，说明刚才可能是 -1 (多一个)，现在移走了刚好 -> 不匹配数减 1
                if (cur[left] == 0) cnt --;
                // 如果变成 1，说明刚才可能是 0 (刚好)，现在移走了一个导致缺货 -> 不匹配数加 1
                else if (cur[left] == 1) cnt ++; 
                
                k --; // 窗口大小恢复
            }

            // ---------------------------------------------------
            // C. 检查结果
            // ---------------------------------------------------
            // 只有当窗口大小足够，且所有字符的不匹配度都归零时，才记录结果
            if (k == len && cnt == 0) ans.push_back(i - len + 1);
        }

        return ans;
    }
};
```

