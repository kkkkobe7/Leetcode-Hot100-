# 494. 目标和

### 动态规划

### 解题思路拆解

**1. 数学魔法：化繁为简**

- 原问题是给每个数选 + 或 -，这听起来很乱。
- 我们不妨把所有选 + 的数归为一堆，记它们的和为 `A`（正数集）。
- 把所有选 - 的数归为另一堆，记它们的和为 `B`（负数集）。
- 根据题目要求，我们有两个方程：`A−B=target` (最终运算结果)`A+B=sum` (所有数字的绝对值总和)
- 把两式相加：`2A=sum+target`
- **推导结论：** `A=(sum+target)/2`

**2. 问题转化：0/1 背包**

- 现在的任务变成了：**从数组 nums 中挑选出若干个数字，使它们的和恰好等于** `A`。问有多少种挑法？
- 这就是标准的 **0/1 背包问题**（每个物品只能选一次），求的是**组合方案数**。

**3. 边界条件判断**

- 如果 `sum+target` 是奇数，没法除以 2，说明不存在这样的整数 `AA`，直接返回 0。
- 如果 `target` 的绝对值比 `sum` 还大，怎么加减都凑不够，直接返回 0。

**4. 空间优化 (滚动数组)**

- 标准 DP 状态是` f[i][j]` (前 i 个物品凑 j)。
- 因为第 i 行只依赖于第 i-1 行，我们可以把二维数组压缩成一维数组 f[j]。
- **关键点：** 一维背包必须**倒序遍历** j，防止同一个物品被重复使用（避免变成完全背包）。

```c++
class Solution {
public:
    static const int N = 2010;
    int f[N];

    int findTargetSumWays(vector<int>& nums, int target) {
        // 一部分为+，和为a，一部分为-，和为b
        // a + b = sum，a - b = target
        // a = (sum + target) / 2, b = (sum - target) / 2;
        // 转换为01背包，多少种方案，和刚好为a
        // f[i][j]表示看过前i个物品，和恰好为j的方案数量 f[i][j] = f[i-1][j] + f[i-1][j-v]
        int sum = 0, n = nums.size();
        for (int i = 0; i < n; i ++) 
            sum += nums[i];
        if (target > sum || target % 2 != sum % 2) return 0;
        target = (sum + target) / 2;
        if (target < 0) return 0;

        f[0] = 1;

        for (int i = 0; i < n; i ++)
        {
            for (int j = target; j >= nums[i]; j --)
                f[j] = f[j] + f[j-nums[i]];
        }
        
        return f[target];

    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 定义为 2010，足够覆盖 target 的计算范围
    // 因为 sum 最大为 1000, target 最大为 1000, 背包容量 (sum+target)/2 不会超过 1000
    // 但为了安全，2000+ 是很好的习惯
    static const int N = 2010;
    
    // DP 数组：f[j] 表示“填满容量为 j 的背包，有多少种方法”
    // 注意：如果是多次调用（LeetCode环境），建议在函数内初始化或使用 vector
    // 这里作为类成员，默认是未定义的，但下面的逻辑会覆盖或使用 f[0]=1，存在一定脏数据风险
    // 建议加上：memset(f, 0, sizeof f);
    int f[N];

    int findTargetSumWays(vector<int>& nums, int target) {
        // ------------------------------------------------
        // 1. 数学推导与转化
        // ------------------------------------------------
        // 设 P 为正数子集之和，N 为负数子集之和
        // P - N = target
        // P + N = sum
        // => 2P = target + sum
        // => P = (target + sum) / 2
        // 问题转化为：从 nums 中选出和为 P 的方案数
        
        int sum = 0, n = nums.size();
        for (int i = 0; i < n; i ++) 
            sum += nums[i];
            
        // ------------------------------------------------
        // 2. 边界条件剪枝
        // ------------------------------------------------
        // 情况 A: abs(target) > sum
        // 即使全加或全减也凑不出 target，直接不可能
        if (abs(target) > sum) return 0;
        
        // 情况 B: (target + sum) 是奇数
        // 2P 必须是偶数，如果是奇数说明无法整除，无解
        // 注意：C++ 中负数取模结果可能是负数，所以这里通常用 abs 或公式推导
        // 您写的 target % 2 != sum % 2 是完全正确的（同奇同偶性判断）
        if ((target + sum) % 2 != 0) return 0; 
        
        // 计算新的目标背包容量 A
        int bagSize = (sum + target) / 2;
        
        // 再次检查背包容量是否合法（虽然上面判断过 abs，但这步防御性编程也不错）
        if (bagSize < 0) return 0;

        // ------------------------------------------------
        // 3. 动态规划 (0/1 背包)
        // ------------------------------------------------
        // 【关键步骤】初始化 DP 数组
        // 必须清空数组，防止脏数据（尤其是类成员变量在LeetCode中复用时）
        memset(f, 0, sizeof f); 
        
        // Base Case: 凑出和为 0 的方案数为 1 (就是什么都不选)
        f[0] = 1;

        // 外层循环：遍历每一个物品 (数字)
        for (int i = 0; i < n; i ++)
        {
            // 内层循环：遍历背包容量
            // 【关键细节】倒序遍历！
            // 从 bagSize 递减到 nums[i]。
            // 如果是正序，意味着 nums[i] 可能会被多次加入背包 (变成完全背包)
            // 倒序保证了计算 f[j] 时使用的是上一轮(i-1)的数据，确保每个物品只选一次
            for (int j = bagSize; j >= nums[i]; j --)
            {
                // 状态转移方程：
                // f[j] (不选当前数的方法数) + f[j - nums[i]] (选当前数的方法数)
                f[j] = f[j] + f[j-nums[i]];
            }
        }
        
        // 返回凑出目标容量 bagSize 的方案总数
        return f[bagSize];
    }
};
```



### 回溯

简洁版代码：

```c++
class Solution {
public:
    int ans;

    void dfs(vector<int>& nums, int k, int sum, int target) // 已经遍历了nums中前k个数字，和为sum
    {
        if (k == nums.size())
        {
            if (sum == target) ans ++;
            return ;
        }
		
        // 一共两种情况
        dfs(nums, k + 1, sum + nums[k], target); // +
        dfs(nums, k + 1, sum - nums[k], target); // -

        return ;
    }

    int findTargetSumWays(vector<int>& nums, int target) {
        dfs(nums, 0, 0, target);
        
        return ans;
    }
};
```

注释版代码：
```c++
class Solution {
public:
    // 全局变量 ans 记录合法方案的数量
    int ans;

    // DFS 函数
    // k: 当前正在做决定的数字的索引 (第 k 个数)
    // sum: 此时此刻，前面 k 个数加减运算后的临时总和
    // target: 我们的终极目标
    void dfs(vector<int>& nums, int k, int sum, int target) 
    {
        // 1. 终止条件 (Base Case)
        // 当 k 等于数组长度时，说明所有数字都做完了选择
        if (k == nums.size())
        {
            // 检查最终结果是否等于 target
            if (sum == target) ans ++;
            return ;
        }

        // 2. 递归分支 (Branching)
        
        // 选项 A：在当前数字 nums[k] 前面放 '+' 号
        // sum 变为 sum + nums[k]
        dfs(nums, k + 1, sum + nums[k], target);
        
        // 选项 B：在当前数字 nums[k] 前面放 '-' 号
        // sum 变为 sum - nums[k]
        dfs(nums, k + 1, sum - nums[k], target);

        return ;
    }

    int findTargetSumWays(vector<int>& nums, int target) {
        // 从第 0 个数字开始，初始和为 0
        dfs(nums, 0, 0, target);
        
        return ans;
    }
};
```

