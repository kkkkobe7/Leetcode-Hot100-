# 322. 零钱兑换

### 解题思路拆解

**1. 核心模型：爬楼梯的变种**

- 想象你要爬到第 amount 层楼梯。
- 你每次可以跳的步数是 coins 数组里的值（比如可以跳 1 步、2 步或 5 步）。
- **目标：** 用最少的跳跃次数到达楼顶。

**2. 定义状态 (DP State)**

- 我们定义 f[j]：凑满金额 j 所需的**最少硬币数量**。
- 我们的目标是求 f[amount]。

**3. 状态转移 (Transition)**

- 假设我现在要凑金额 j。
- 我可以从哪里跳过来？如果我选了硬币 1，那我之前的状态就是 f[j-1]，步数 +1。如果我选了硬币 5，那我之前的状态就是 f[j-5]，步数 +1。
- **决策：** 我选那个“之前的状态”最小的那个。
- `f[j] = min(f[j], f[j - coin] + 1)`

**4. 初始状态与“无穷大”**

- f[0] = 0：凑金额 0 不需要任何硬币。
- f[其他] = Infinity：为什么？因为我们要取 min（最小值）。一开始要先把数组填满最大值，这样后续计算出来的较小值才能覆盖它。如果初始化为 0，min(0, ...) 永远是 0，就没法更新了。

**5. 循环顺序 (完全背包)**

- 因为硬币可以**重复使用**（比如可以拿两个 5 元），所以在遍历背包容量（金额）时，我们需要**从小到大**遍历 (j 从 coin 到 amount)。
- *对比：如果是 0/1 背包（硬币只能用一次），则需要从大到小遍历。*



此处使用了完全背包到0/1背包的简化（递推公式简化），原本需要三重循环，第三重用于遍历个数，证明如下

```c++
// 原本的递推公式
f[i][j] = min(f[i-1][j-v]+1, f[i-1][j-2*v]+2, ..., f[i-1][j-k*v]+k)
// 同理
f[i-1][j-v] = min(f[i-1][j-2*v]+1, f[i-1][j-3*v]+3, ..., f[i-1][j-k*v]+k-1)
    
// 可以注意到，f[i][j] = f[i-1][j-v]+1
```

也用到了二维到一维的优化，`f[i][j]->f[j]`



简洁版代码：

```c++
class Solution {
public:
    static const int N = 1e4 + 10;
    int f[N];
    
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();

        for (int i = 1; i <= amount; i ++) f[i] = 1e4+10;

        for (int i = 0; i < n; i ++) // 遍历硬币
            for (int j = coins[i]; j <= amount; j ++) // 遍历体积
                f[j] = min(f[j], f[j-coins[i]] + 1);

        if (f[amount] == 1e4+10) return -1;
        return f[amount];
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 定义得足够大，覆盖 amount 的最大值
    static const int N = 1e4 + 10;
    
    // DP 数组：f[j] 表示凑成金额 j 所需的最少硬币数
    // 注意：作为类成员变量，C++ 不保证 f 默认初始化为 0。
    // 虽然您的代码后面有循环赋值，但 f[0] 必须确保是 0。
    // 建议在函数内显式初始化或使用 vector。
    int f[N]; 
    
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();

        // 1. 初始化
        // 我们需要求最小值，所以先把数组填满一个“不可能的大数”
        // 这里用 1e4+10 是因为硬币最小面额是 1，凑 amount 最多也就 amount 个硬币
        // 所以只要比 amount 大的值都可以代表“无穷大”
        for (int i = 1; i <= amount; i ++) f[i] = 1e4+10;
        
        // 关键：凑 0 元需要 0 个硬币
        // 您的代码里虽然没写这句，但如果 f 恰好被内存初始化为 0 则通过。
        // 为了代码健壮性，必须加上：
        f[0] = 0; 

        // 2. 动态规划 (完全背包模板)
        // 外层循环：遍历每一枚硬币
        for (int i = 0; i < n; i ++)
        {
            // 内层循环：遍历金额 (从当前硬币面额开始，直到总金额)
            // 正序遍历 (j++) 代表硬币可以被重复使用
            for (int j = coins[i]; j <= amount; j ++)
            {
                // 转移方程：
                // 不选这枚硬币：保持 f[j] 原样
                // 选这枚硬币： f[j - coins[i]] + 1
                // 取二者较小值
                f[j] = min(f[j], f[j-coins[i]] + 1);
            }
        }

        // 3. 结果判断
        // 如果 f[amount] 还是初始化的那个大数，说明没法凑出这个金额
        if (f[amount] == 1e4+10) return -1;
        
        return f[amount];
    }
};
```

