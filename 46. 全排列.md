# 46. 全排列

解题思路拆解

**1. 形象理解：填格子**
*   假设你有 $n$ 个空格子，要把 $n$ 个不同的数字填进去。
*   **第一个格子**：你有 $n$ 种选择。
*   **第二个格子**：因为一个数字只能用一次，你剩下 $n-1$ 种选择。
*   **以此类推**...直到填满所有格子，就形成了一个排列。

**2. 核心技术：决策树与回溯**
我们可以把这个过程看作一棵树的遍历：
*   **路径**：已经做出的选择（即代码中的 `cur`）。
*   **选择列表**：当前还可以做的选择（即代码中 `vis[i]` 为 `false` 的元素）。
*   **结束条件**：格子填满了（`cur.size() == nums.size()`）。

**3. 回溯的关键：撤销选择**
*   当我们探索完一种可能性后（比如填好了 `[1, 2, 3]`），我们需要“退回”一步。
*   退回到 `[1, 2]` 的状态，把 `3` 拿出来，标记为“未使用”，再去尝试填入其他的数字。这就是代码中 `pop_back()` 和 `vis[k] = false` 的作用。

简洁版代码：

```c++
class Solution {
public:
    vector<vector<int>> ans;
    // vector<int> cur
    static const int N = 10;
    bool vis[N];

    void dfs(int k, vector<int>& v, vector<int>& cur) // 将v[k]放到cur的下一位
    {
        cur.push_back(v[k]);
        vis[k] = true;
        if (cur.size() == v.size()) ans.push_back(cur);
        else
        {
            for (int i = 0; i < v.size(); i ++)
                if (!vis[i]) 
                    dfs(i, v, cur);
        }
        
        vis[k] = false;
        cur.pop_back();
    }

    vector<vector<int>> permute(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i ++)
        {
            vector<int> a;
            dfs(i, nums, a);
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    vector<vector<int>> ans; // 存储最终结果
    static const int N = 10;
    bool vis[N]; // 记录哪些下标的数字已经被用过了

    // dfs 函数含义：当前正在处理第几个位置，并尝试把 v[k] 放进去
    void dfs(int k, vector<int>& v, vector<int>& cur) 
    {
        // 1. 做选择：把当前数字放入路径中，并标记为已使用
        cur.push_back(v[k]);
        vis[k] = true;

        // 2. 终止条件：如果路径长度等于数组长度，说明填满了
        if (cur.size() == v.size()) {
            ans.push_back(cur);
        }
        else
        {
            // 3. 递归：继续为下一个格子选择数字
            for (int i = 0; i < v.size(); i ++) {
                if (!vis[i]) { // 只要没用过，就可以选
                    dfs(i, v, cur);
                }
            }
        }
        
        // 4. 回溯：撤销选择
        // 这是最重要的一步！为了让上一层递归能尝试其他数字，
        // 必须把当前数字从路径中取出，并重新标记为未使用
        vis[k] = false;
        cur.pop_back();
    }

    vector<vector<int>> permute(vector<int>& nums) {
        ans.clear();
        int n = nums.size();
        // 初始化 vis 数组
        memset(vis, 0, sizeof vis);

        // 依次以每一个数字作为排列的开头进行搜索
        for (int i = 0; i < n; i ++)
        {
            vector<int> cur;
            dfs(i, nums, cur);
        }
        return ans;
    }
};
```

