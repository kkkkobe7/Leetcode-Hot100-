# 238. 除了自身之外数组的乘积

进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，**输出数组 不被视为 额外空间**。）

### 解题思路拆解

**1. 核心直觉：分而治之**

- 题目要求算出除了 nums[i] 以外所有数的乘积。
- 我们可以把这个乘积拆成两部分：**左半边**：nums[i] 左边所有数的乘积（前缀乘积）。**右半边**：nums[i] 右边所有数的乘积（后缀乘积）。
- ans[i] = (左边的乘积) * (右边的乘积)

**2. 朴素做法 (使用额外空间)**

- 

- 定义两个数组 L 和 R。L[i] 存 0 到 i-1 的乘积。R[i] 存 i+1 到 n-1 的乘积。

- 最后 ans[i] = L[i] * R[i]。

- 但这需要 `O(N)O(N)` 的额外空间。

    

**3. 进阶优化 (达到 O(1) 额外空间)**

- 
- 题目允许我们使用**输出数组** ans，且不计入额外空间。
- **策略：**先用 ans 数组来充当 L 数组。对于 R 数组，我们不需要真的开辟一个数组存它。我们可以用一个变量 post（后缀积），从右往左遍历时动态累乘即可。在第二轮遍历中，直接把算出来的动态后缀积乘到 ans[i] 里面去。

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();

        vector<int> ans(n, 1);
        for (int i = 1; i < n ;i ++)
        {
            ans[i] = ans[i-1] * nums[i-1]; // 从左到右计算前缀和（不包含自己）
        }
        int post = 1; // 后缀和
        for (int i = n - 2; i >=0; i --)
        {
            post *= nums[i + 1];
            ans[i] *= post;
        }
        return ans;
    }
};
```

注释版：

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();

        // 初始化结果数组 ans，全部填 1
        // 这里的 ans[i] 在第一轮循环中将用于存储“nums[i] 左边所有元素的乘积”
        vector<int> ans(n, 1);
        
        // -------------------------------------------------------
        // 第一轮遍历：计算前缀乘积 (Left Product)
        // -------------------------------------------------------
        // i 从 1 开始，因为第 0 个元素左边没有东西（默认为 1）
        for (int i = 1; i < n ;i ++)
        {
            // ans[i] = (i-1位置的前缀积) * (nums[i-1]的值)
            // 此时，ans[i] 代表 nums[0]...nums[i-1] 的乘积
            ans[i] = ans[i-1] * nums[i-1]; 
        }
        
        // -------------------------------------------------------
        // 第二轮遍历：计算后缀乘积 (Right Product) 并合并
        // -------------------------------------------------------
        // post 变量用来动态维护“当前位置右边所有元素的乘积”
        int post = 1; 
        
        // 从倒数第二个元素开始往前遍历
        // (最后一个元素右边没有东西，post 初始为 1，直接乘上去也不影响)
        for (int i = n - 2; i >= 0; i --)
        {
            // 1. 更新后缀积 post
            // 现在 post 变成了 nums[i+1]...nums[n-1] 的乘积
            post *= nums[i + 1];
            
            // 2. 合并结果
            // 最终结果 = (左边乘积，已经在ans里了) * (右边乘积 post)
            ans[i] *= post;
        }
        
        // 注意：循环中漏掉了对 ans[n-1] 的处理吗？
        // 没有。因为 ans[n-1] 的右边是空的 (1)。
        // 第一轮结束后 ans[n-1] 已经存好了左边所有的乘积。
        // 第二轮循环从 n-2 开始，ans[n-1] 保持原样，正好是正确答案。
        // 也就是 post 初始为 1，实际上隐含了处理最右侧元素的逻辑。
        
        return ans;
    }
};
```

