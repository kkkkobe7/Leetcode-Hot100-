# 221. 最大正方形

 解题思路拆解 (前缀和法)

**1. 核心思想**
*   正方形全是 '1'，意味着什么？
*   意味着：这个正方形区域内的**元素总和**，应该等于它的**面积**。
*   例如：一个 $3 \times 3$ 的正方形，如果里面全是 '1'，那么这 9 个格子加起来和应该是 9。如果有一个是 '0'，和就是 8，不满足条件。

**2. 快速求和工具：二维前缀和**
*   我们构建一个数组 `presum[i][j]`，表示从矩阵左上角 `(0,0)` 到当前点 `(i-1, j-1)` 围成的矩形内所有元素的和。
*   利用容斥原理，我们可以瞬间计算出任意一个子矩形 `(x1, y1)` 到 `(x2, y2)` 的和：
    $$Sum = P(x2, y2) - P(x1-1, y2) - P(x2, y1-1) + P(x1-1, y1-1)$$

**3. 遍历与验证**
*   我们遍历矩阵中的每一个点，把它当作正方形的**右下角**。
*   然后，我们尝试扩大正方形的边长 `k`。
*   检查：以当前点为右下角，边长为 `k` 的区域，里面的和是不是等于 $k \times k$？
    *   如果是，说明找到一个合法的正方形，更新最大答案。
    *   如果不是，说明里面混入了 '0'，因为我们要找全是 '1' 的，通常再往大找也不行了（或者已经不满足全1条件），可以停止。



简洁版代码：

```c++
class Solution {
public:
    static const int N = 310;
    int presum[N][N]; // presum[i][j]代表二维矩阵中以[0][0]为左上角，[i-1][j-1]为右下角的二维矩阵的元素之和
    
    int maximalSquare(vector<vector<char>>& matrix) {
        // 最大正方形的边长
        int ans = 0;
        int n = matrix.size(), m = matrix[0].size();
        for (int i = 1; i <= n; i ++) // 假设从1开始，便于后续计算
        {
            for (int j = 1; j <= m; j ++)
            {
                presum[i][j] = presum[i-1][j] + presum[i][j-1] - presum[i-1][j-1];
                if (matrix[i-1][j-1] == '1')
                {
                    presum[i][j] ++; // 当前位置为1，则需要++
                    int max_len = min(i, j);
                    for (int k = max(1, ans); k <= max_len; k ++)
                    {
                        if (presum[i][j] - presum[i-k][j] - presum[i][j-k] + presum[i-k][j-k] == k * k)
                            ans = k;
                        else break;
                    }
                }
            }
        }
        return ans*ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 定义常量 N，稍大于题目给定的最大边长 300
    static const int N = 310;
    
    // 二维前缀和数组
    // presum[i][j] 表示：原矩阵中从左上角 (0,0) 到 (i-1, j-1) 这个矩形区域内的元素之和
    // 注意：这里 i, j 是从 1 开始的，为了处理边界（第 0 行和第 0 列作为 padding，值为 0）
    int presum[N][N]; 
    
    int maximalSquare(vector<vector<char>>& matrix) {
        int ans = 0; // 记录找到的最大正方形的边长
        int n = matrix.size();
        int m = matrix[0].size();
        
        // 遍历整个矩阵，计算前缀和，并尝试寻找正方形
        for (int i = 1; i <= n; i ++) 
        {
            for (int j = 1; j <= m; j ++)
            {
                // 1. 计算二维前缀和（容斥原理）
                // 当前区域和 = 上方区域 + 左方区域 - 左上重复区域 + 当前格子值
                presum[i][j] = presum[i-1][j] + presum[i][j-1] - presum[i-1][j-1];
                
                // 如果当前格子是 '1'，我们才有可能以此为右下角构成正方形
                if (matrix[i-1][j-1] == '1')
                {
                    presum[i][j] ++; // 将当前格子的值（1）加进去
                    
                    // 2. 尝试寻找以 (i, j) 为右下角的最大正方形
                    // 理论上边长 k 最大不能超过当前的坐标限制 i 和 j
                    int max_len = min(i, j);
                    
                    // 优化：k 不需要从 1 开始找
                    // 我们只关心能不能找到比当前记录的 ans 更大的正方形
                    // 或者至少和 ans 一样大（为了逻辑严密，通常检查 k > ans）
                    // 您这里的逻辑是从 max(1, ans) 开始，这个剪枝思路是对的
                    // 不过通常为了找更大的，k 从 ans + 1 开始尝试会更高效，
                    // 但由于这道题如果当前点是1，至少边长是1，且要考虑更新逻辑，目前的写法也行。
                    // 更好的逻辑通常是倒序检查 k，或者二分 k。
                    // 这里的逻辑是：从小到大尝试边长 k
                    for (int k = max(1, ans); k <= max_len; k ++)
                    {
                        // 3. 核心验证：利用前缀和快速计算区域和
                        // 计算以 (i, j) 为右下角，边长为 k 的正方形区域内的元素和
                        int sum = presum[i][j] - presum[i-k][j] - presum[i][j-k] + presum[i-k][j-k];
                        
                        // 如果区域和 == 面积 (k * k)，说明全是 '1'
                        if (sum == k * k)
                            ans = k; // 更新最大边长
                        else 
                            // 剪枝：如果边长为 k 的时候已经不满足全为 1 了
                            // 那么边长 k+1 的正方形包含这个 k 的正方形，肯定包含 0，更不可能全为 1
                            // 所以直接 break，不用再往大了找
                            break; 
                    }
                }
            }
        }
        // 返回面积
        return ans * ans;
    }
};
```

