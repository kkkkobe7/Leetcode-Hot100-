# 221. 最大正方形

### 如何判断一个正方形？

一种做法是，判断一个正方形区域内是否满足均为1。

如果对于每一个可能的正方形都这样做，暴力遍历正方形内所有元素显然有点复杂。那么可以运用到前缀和的思想，用常数时间计算一个正方形区域内的元素和是否于面积相等。

### 剪枝

如果可以判断一个正方形，那么在遍历整个二维矩阵的时候，什么样的情况可以省略？

1. 如果当前位置为0，那么不需要进行正方形判断
2. 由于是找最大正方形，那么我们不需要每次都从边长为1的情况开始，而是从已有的最大边长开始。
3. 如果以某个点为正方形右下角来计算，那么其前面的前缀和都是计算好的，那么就可以和计算前缀和的流程合并。

代码如下：

```c++
class Solution {
public:
    static const int N = 310;
    int presum[N][N]; // presum[i][j]代表二维矩阵中以[0][0]为左上角，[i-1][j-1]为右下角的二维矩阵的元素之和
    
    int maximalSquare(vector<vector<char>>& matrix) {
        // 最大正方形的边长
        int ans = 0;
        int n = matrix.size(), m = matrix[0].size();
        for (int i = 1; i <= n; i ++) // 假设从1开始，便于后续计算
        {
            for (int j = 1; j <= m; j ++)
            {
                presum[i][j] = presum[i-1][j] + presum[i][j-1] - presum[i-1][j-1];
                if (matrix[i-1][j-1] == '1')
                {
                    presum[i][j] ++; // 当前位置为1，则需要++
                    int max_len = min(i, j);
                    for (int k = max(1, ans); k <= max_len; k ++)
                    {
                        if (presum[i][j] - presum[i-k][j] - presum[i][j-k] + presum[i-k][j-k] == k * k)
                            ans = k;
                        else break;
                    }
                }
            }
        }
        return ans*ans;
    }
};
```

