# 139. 单词拆分

### 解题思路拆解

**1. 核心直觉：接力棒游戏**

- 我们要想知道字符串 s (比如 "leetcode") 能不能被拼出来，可以把它看作一场接力赛。
- 如果我们要跑到终点 i，必须满足两个条件：有人已经成功跑到了中间某个位置 j (即 dp[j] 为 true)。从位置 j 到位置 i 的这段距离（子串），刚好是字典里的一个单词（能够完成最后一棒）。

**2. 定义状态 (DP Definition)**

- 我们定义 dp[i] 表示：**字符串 s 的前 i 个字符（即 s[0...i-1]）能否被成功拆分成字典里的单词。**
- 我们的目标是求 dp[n]（n 是字符串长度）。

**3. 状态转移 (Transition)**

- 我们怎么计算 dp[i] 呢？
- 我们需要回头看。遍历所有可能的分割点 j (从 0 到 i-1)：检查两件事：**前半段行不行？** dp[j] 是 true 吗？**后半段行不行？** s[j...i-1] 这个子串在字典里吗？只要找到**任意一个**这样的 j，那么 dp[i] 就是 true。

**4. 初始状态 (Base Case)**

- dp[0] 代表空字符串。

- 逻辑上，空字符串不需要任何单词就能拼成（或者说被视为合法的起始点），所以 dp[0] = true。

    

简洁版代码：

```c++
class Solution {
public:
    static const int N = 310;
    bool dp[N];
    // dp[i] 表示s.substr(0, i)可以被拆分
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict(wordDict.begin(), wordDict.end());
        int n = s.length();

        dp[0] = true; // 空字符串可拆分

        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j] && dict.contains(s.substr(j, i - j))) 
                {
                    dp[i] = true;
                    break; // 找到一种拆分即可，无需继续
                }
            }
        }

        return dp[n];
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 定义为 310，覆盖题目通常限制 (字符串长度 <= 300)
    static const int N = 310;
    
    // dp[i]: 表示字符串 s 的前 i 个字符组成的子串，是否可以被空格拆分为字典中的单词
    bool dp[N];

    bool wordBreak(string s, vector<string>& wordDict) {
        // 1. 数据结构优化
        // 将 vector 转为 unordered_set (哈希集合)
        // 这样查询一个单词是否存在的时间复杂度从 O(M) 降为 O(1)
        unordered_set<string> dict(wordDict.begin(), wordDict.end());
        
        int n = s.length();

        // 2. 初始化 Base Case
        // dp[0] 表示空串，默认是可以被“拆分”的（作为起始状态）
        // 记得初始化 dp 数组其他位置为 false（C++全局变量默认是false，局部变量需手动初始化，这里是类成员，如果不重置可能有脏数据风险）
        // 建议：memset(dp, 0, sizeof dp); dp[0] = true;
        dp[0] = true; 

        // 3. 动态规划填表
        // i 代表当前子串的长度，从 1 到 n
        for (int i = 1; i <= n; ++i) {
            // j 代表分割点，把 s[0...i-1] 分割成 s[0...j-1] 和 s[j...i-1]
            // j 遍历从 0 到 i-1
            for (int j = 0; j < i; ++j) {
                // substr(start_pos, length)
                // s.substr(j, i - j) 取出的是从索引 j 开始，长度为 i-j 的子串
                // 也就是 s[j] 到 s[i-1] 这段字符
                
                // 核心转移方程：
                // 如果 前半段(0到j)能拆分 AND 后半段(j到i)是字典里的单词
                if (dp[j] && dict.contains(s.substr(j, i - j))) 
                {
                    dp[i] = true;
                    // 剪枝优化：只要找到一种切分方式能到达 i，就说明 dp[i] 可行
                    // 不需要再尝试其他切分点了，直接跳出内层循环
                    break; 
                }
            }
        }

        // 返回前 n 个字符（即整个字符串）是否可拆分
        return dp[n];
    }
};
```

