# 560. 和为K的子数组

解题思路拆解

**1. 前缀和的物理意义**
*   设 `presum[i]` 为数组前 `i` 个元素的和。
*   任意一个连续子数组 `nums[i...j]` 的和可以表示为：`presum[j] - presum[i-1]`。
*   我们的目标是找到满足 `presum[j] - presum[i-1] == k` 的组合数量。

**2. 公式变形**
*   将公式变形得：`presum[i-1] = presum[j] - k`。
*   **翻译成大白话**：当我计算出当前位置的前缀和 `presum[j]` 时，我只需要看看在**之前**的路程中，有多少个位置的前缀和刚好等于 `presum[j] - k`。

**3. 哈希表的作用**
*   我们需要记录每一个出现过的前缀和及其出现的**次数**。
*   `Map<前缀和的值, 出现的次数>`。

**4. 代码逻辑**

*   通常的写法是先在 Map 里存入 `{0, 1}`，然后循环。
*   **现在写法**：在循环内部，先执行 `cnt[presum] ++`，再更新 `presum += a`。
    *   第一轮循环：`presum` 是 0，先存入 `cnt[0] = 1`。然后 `presum` 变成第一个数的值。
    *   这实际上完美地初始化了“前缀和为 0 出现过 1 次”的情况，逻辑非常严密且精炼。

简洁版代码：

```c++
class Solution {
public:
    // 子数组是连续的
    int subarraySum(vector<int>& nums, int k) {
        int ans = 0, presum = 0;

        unordered_map<int, int> cnt;
        for (auto& a: nums)
        {
            cnt[presum] ++;
            presum += a;
            ans += cnt[presum-k] ;
        }
        return ans;

    }
};
```

注释版代码：

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int ans = 0, presum = 0;

        // 哈希表：记录每个前缀和出现的次数
        // Key: 前缀和的值, Value: 出现次数
        unordered_map<int, int> cnt;

        for (auto& a: nums)
        {
            // 1. 将“当前位置之前”的前缀和记录到 Map 中
            // 第一次进入循环时，presum 为 0，这一步相当于初始化了 cnt[0] = 1
            cnt[presum] ++;

            // 2. 加上当前元素，更新为“当前位置”的前缀和
            presum += a;

            // 3. 核心逻辑判断
            // 我们寻找是否存在一个历史前缀和 target，使得：presum - target = k
            // 推导得：target = presum - k
            // 如果在 Map 中找到了 target，说明从那个位置到当前位置的子数组和恰好为 k
            // 我们直接加上那个前缀和出现的次数
            if (cnt.count(presum - k)) {
                ans += cnt[presum - k];
            }
        }
        
        return ans;
    }
};
```

