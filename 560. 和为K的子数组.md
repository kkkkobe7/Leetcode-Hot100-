# 560. 和为K的子数组

解题思路拆解

**1. 暴力法的瓶颈**
*   最简单的想法是枚举所有的子数组，算出它们的和。
*   两层循环确定起点和终点，再加一层循环求和（或利用前缀和数组相减）。
*   时间复杂度是 $O(N^2)$，在数据量大时会超时。我们必须优化到 $O(N)$。

**2. 公式变形 (核心逻辑)**
*   子数组 `nums[i...j]` 的和可以表示为：`preSum[j] - preSum[i-1] == k`。
*   移项变形一下：**`preSum[i-1] == preSum[j] - k`**。
*   这个公式告诉我们：
    *   当我们扫描到第 `j` 个数字，且当前的前缀和是 `preSum[j]` 时。
    *   我们需要回头看：**在之前有没有出现过一个前缀和，它的值刚好等于 `preSum[j] - k`？**
    *   如果有，出现了几次，就说明有几个子数组是以当前位置 `j` 结尾且和为 `k` 的。

**3. 哈希表的作用**
*   我们需要一个容器来记录：“某个前缀和出现了多少次”。
*   `Key`: 前缀和的值。
*   `Value`: 这个前缀和出现的次数。

**4. 细节与初始化**
*   **空前缀和：** 在一开始，还没有加任何数字时，前缀和为 0。这个“0”虽然没有对应的子数组，但它是计算的基础（比如子数组从头开始 `nums[0...j]`，相当于 `preSum[j] - preSum[-1]`）。
*   所以在常规写法中，我们需要预先在 map 中放入 `{0, 1}`。
*   在代码通过调整循环内的执行顺序（先放 map，再更新 sum，再查 map），巧妙地处理了 `{0, 1}` 的初始化问题，逻辑是自洽的。



简洁版代码：

```c++
class Solution {
public:
    unordered_map<int, int> map;

    int subarraySum(vector<int>& nums, int k) {
        int presum = 0, ans = 0;
        for (auto& a: nums)
        {
            map[presum] ++; // 将之前的前缀和加入map
            presum += a; // 更新当前前缀和
            ans += map.contains(presum - k)? map[presum - k]: 0;
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 【建议移入函数内】防止多用例数据污染
    unordered_map<int, int> map;

    int subarraySum(vector<int>& nums, int k) {
        // 清空哈希表，确保环境纯净 (针对 LeetCode 机制的防御性编程)
        map.clear();
        
        int presum = 0, ans = 0;
        
        // 遍历数组
        for (auto& a: nums)
        {
            // 1. 记录历史前缀和
            // 在更新当前 presum 之前，先把“上一步”的前缀和放入 map
            // 第一轮循环时，这里放入的是 map[0]++，相当于初始化了前缀和为 0 的情况
            map[presum] ++; 
            
            // 2. 更新当前前缀和
            presum += a; 
            
            // 3. 查找符合条件的历史前缀和
            // 公式：当前前缀和 - 历史前缀和 = k
            // 所以我们需要找：历史前缀和 = 当前前缀和 - k
            // 如果 map 中存在这个值，说明找到了对应数量的合法子数组
            
            // map.contains 是 C++20 新特性。
            // 兼容写法：if (map.count(presum - k)) ans += map[presum - k];
            ans += map.contains(presum - k) ? map[presum - k] : 0;
        }
        return ans;
    }
};
```



