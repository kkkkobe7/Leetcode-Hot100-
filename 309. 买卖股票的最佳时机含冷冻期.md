# 309. 买卖股票的最佳时机含冷冻期

解题思路拆解

**1. 核心矛盾：冷冻期的限制**
*   不能连续交易：卖出的第二天不能买入。
*   这意味着：如果你想在今天**买入**，你昨天的状态不能是**刚刚卖出**。

**2. 状态机的三个状态划分为：**
为了清晰地描述每一天结束后的情况，我们定义三个变量（状态）：

*   **状态 `a` (持有股票)**：
    *   情况 1：昨天就持有，今天不动。
    *   情况 2：昨天是不持有的可买状态（即不在冷冻期），今天刚买入。
*   **状态 `b` (不持股，且可买入)**：
    *   情况 1：昨天就已经是这个状态，今天继续观望。
    *   情况 2：昨天是冷冻期（刚卖完），今天解冻了。
*   **状态 `c` (不持股，且在冷冻期)**：
    *   唯一情况：今天刚刚把股票卖掉了。

**3. 状态转移逻辑 (关键)**
*   `新 a` = `max(旧 a, 旧 b - 今日价格)`
    *   *解释：继续持有，或者从“可买状态”投入资金买入。*
*   `新 b` = `max(旧 b, 旧 c)`
    *   *解释：继续观望，或者从“冷冻期”自然恢复到“可买状态”。*
*   `新 c` = `旧 a + 今日价格`
    *   *解释：卖掉手中的股票。*

**4. 初始状态 (第一天)**
*   `a = -prices[0]`：第一天买入。
*   `b = 0`：第一天不买，也没卖，属于可买状态。
*   `c = 0`：第一天不可能处于卖出后的冷冻期（因为没东西可卖）。



简洁版代码：

```c++
class Solution {
public:
    static const int N = 5e3 + 10;
    int dp[N];
    
    // 可以多次买卖（不能同时参与多笔），且有冷冻期
    // 状态可以划分为 a. 过完今天手上有股票 b. 今天不卖但手上没有 c. 今天卖掉变成冷冻期
    /*
    状态转移方程：
    过完今天手上有股票 = 昨天手上有股票 或 昨天手上没有股票今天买（不可以从冷冻期转移） a = max(a, b - prices[i])
    今天不卖但手上没有 = 昨天手上没股票 或 或 昨天是冷冻期 b = max(b, c)
    冷冻期 = 本来手上有股票但是昨天卖掉了 c = a + prices[i]
    */

    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int a = - prices[0], b = 0, c = 0; // 初始化状态
        
        // 如果在计算 c 时使用了已经买入的 a，相当于你同一天买入又卖出，虽然在数学上利润抵消不会出错，但在逻辑上这不代表“冷冻期”。使用 prev_a 这种写法是最稳健的。
        // int a0 = a, b0 = b, c0 = c; // 可以简化
        for (int i = 1; i < n; i ++)
        {
            a = max(a, b - prices[i]);
            b = max(b, c);
            c = a + prices[i];
            
        }
        return max(b, c);

    }
};
```

注释版：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n <= 1) return 0;

        // a: 过完今天，手里【持有】股票的最大收益
        // b: 过完今天，手里【没有】股票，且【不在】冷冻期的最大收益（即明天可以买）
        // c: 过完今天，手里【没有】股票，且【在】冷冻期的最大收益（即今天刚卖，明天不能买）
        int a = -prices[0]; 
        int b = 0;
        int c = 0;

        for (int i = 1; i < n; i++) {
            // 为了防止更新 a 的时候影响到后面 c 的计算，我们需要记录昨天的状态
            int prev_a = a;
            int prev_b = b;
            int prev_c = c;

            // 1. 更新 a：要么昨天就持有，要么昨天是可买状态今天买入
            a = max(prev_a, prev_b - prices[i]);

            // 2. 更新 b：要么昨天就是可买状态，要么昨天是冷冻期今天解冻了
            b = max(prev_b, prev_c);

            // 3. 更新 c：今天卖掉了昨天的股票
            c = prev_a + prices[i];
        }

        // 最后一天，持有股票（a）肯定不是最优解
        // 最大收益一定在“解冻状态(b)”或“刚卖掉状态(c)”中产生
        return max(b, c);
    }
};
```

