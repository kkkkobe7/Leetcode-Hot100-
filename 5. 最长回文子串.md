# 5. 最长回文子串

### 中心扩展法

解题思路拆解

**1. 回文串的特性：对称**
*   回文串是从中间向两边对称的。因此，我们可以遍历字符串，把每一个位置都当作“中心”，尝试向两边扩散，直到不再满足回文条件。

**2. 难点：中心的奇偶性**
*   **奇数回文**：中心是一个字符（如 "aba"，中心是 'b'）。
*   **偶数回文**：中心是两个字符（如 "abba"，中心是 "bb"）。

**3. 优化：合并处理相同字符（你的代码核心亮点）**
*   **将连续相同的字符看作一个整体作为“中心”**。
*   例如字符串 `"baaaab"`，中间的 `"aaaa"` 可以直接作为中心。
    *   这样做不仅同时处理了奇偶情况，还大大减少了重复计算。
    *   一旦处理完这组相同的字符，下一次搜索可以直接跳过它们（`i = r`）。

**4. 扩展步骤**
1.  找到当前位置 `i` 及其右侧所有连续相同的字符，确定当前的中心范围 `[i, r-1]`。
2.  以这个范围为起点，设置左右指针 `l = i-1` 和 `r`。
3.  向两边扩散：只要 `s[l] == s[r]`，就说明回文在增长，记录并更新最大长度。



简洁版代码：

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size(), i = 0;
        string ans = s.substr(0, 1);
        // 中心扩展法
        while (i < n - 1)
        {
            // 找到每一个连续相同元素的中心，然后向两侧扩展
            int l = i - 1, r = i + 1;
            while (r < n && s[r - 1] == s[r]) r ++;
            if (r - i > ans.size()) ans = s.substr(i, r - i);
            i = r; // i 至少是i+1
            while (l >= 0 && r < n)
            {
                if (s[l] == s[r])
                {
                    if (r - l + 1 > ans.size()) ans = s.substr(l, r - l + 1);
                    l --;
                    r ++;
                }
                else break;
            }
        }
        return ans;
    }
};
```



注释版代码：

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n <= 1) return s;

        int i = 0;
        string ans = s.substr(0, 1); // 初始结果为第一个字符

        // 遍历每一个可能的中心
        while (i < n)
        {
            // 1. 确定“相同字符中心”的右边界
            // 例如 "baaaab"，当 i 指向第一个 'a' 时，我们将 r 移到第一个 'b'
            int l = i - 1;
            int r = i + 1;
            while (r < n && s[r] == s[i]) {
                r++;
            }

            // 2. 更新下一步扫描的起点
            // 既然 [i, r-1] 全是相同的字符，那么它们中间产生的子回文已经包含在本次扩展中了
            int next_i = r; 

            // 3. 检查当前的“相同字符中心”本身是否就是最长的
            if (r - i > ans.size()) {
                ans = s.substr(i, r - i);
            }

            // 4. 中心扩展：向左右两侧延伸
            // 只要左右字符相等，就说明回文在变长
            while (l >= 0 && r < n && s[l] == s[r])
            {
                // 计算当前发现的回文长度
                int currentLen = r - l + 1;
                if (currentLen > ans.size()) {
                    ans = s.substr(l, currentLen);
                }
                l--; // 向左扩
                r++; // 向右扩
            }

            // 移动到下一个不同的字符作为中心起点
            i = next_i;
        }
        return ans;
    }
};
```

### 动态规划法

 解题思路拆解

**1. 定义状态 (State Definition)**
*   我们用 `dp[i][j]` 表示字符串从索引 `i` 到 `j` 的子串（即 `s[i...j]`）是否为回文串。
*   如果是回文，`dp[i][j] = 1`；否则为 `0`。

**2. 状态转移方程 (Transition)**
如何判断 `s[i...j]` 是不是回文？
*   **前提条件**：首尾字符必须相等，即 `s[i] == s[j]`。
*   **子问题逻辑**：
    *   如果子串长度很短（比如只有 1 个、2 个或 3 个字符），只要首尾相等，它就是回文。
    *   如果子串较长，我们需要看去掉首尾后的“内部”是不是回文。即：`dp[i+1][j-1]` 必须为 `1`。
*   **合并公式**：`dp[i][j] = (s[i] == s[j]) && (内部为空 或 dp[i+1][j-1])`。
    *   *注：“内部为空”在代码中体现为 `i + 1 > j - 1`，即长度小于等于 3。*

**3. 确定遍历顺序（核心难点）**
*   观察发现：为了计算 `dp[i][j]`，我们需要先知道 `dp[i+1][j-1]`。
*   `i+1` 代表**下一行**，`j-1` 代表**左边一列**。
*   **结论**：为了保证计算当前行时，它依赖的“下一行”已经算好了，我们的 `i` 必须 **从大到小（倒序）** 遍历。

**4. 记录最优解**
*   在填表过程中，只要发现 `dp[i][j] == 1`，就计算当前长度 `j - i + 1`。
*   如果比之前记录的 `maxlen` 长，就更新起始位置 `max_i` 和最大长度。

简洁版代码：

```c++
class Solution {
public:
    static const int N = 1010;
    int dp[N][N]; //dp[i][j] 表示i-j的子串是否是回文串
    
    string longestPalindrome(string s) {
        int n = s.size(), max_i = 0, maxlen = 1;
        for(int i = n - 1; i >= 0; i --){
            dp[i][i] = 1;
            for(int j = i + 1; j < n; j ++){
                dp[i][j] = (s[i] == s[j]) && (i + 1 > j - 1 || dp[i+1][j-1]);
                if(dp[i][j] && j - i + 1 > maxlen){
                    max_i = i;
                    maxlen = j - i + 1;
                }
            }
        }
        return s.substr(max_i, maxlen);
    }
};
```

注释版代码：

```c++
class Solution {
public:
    static const int N = 1010;
    // dp[i][j] 代表字符串 s 从下标 i 到 j 的子串是否为回文
    int dp[N][N]; 
    
    string longestPalindrome(string s) {
        int n = s.size();
        if (n < 2) return s;

        // 初始化：记录最长回文串的起始位置和长度
        int max_i = 0, maxlen = 1;
        
        // 记得重置 DP 数组（LeetCode 环境中静态数组会被复用）
        memset(dp, 0, sizeof dp);

        // 外层循环 i 代表子串的左边界，倒序遍历
        // 为什么要倒序？因为 dp[i][j] 依赖于 dp[i+1][j-1]，
        // 我们必须先把“下面”的行算出来。
        for(int i = n - 1; i >= 0; i --){
            // 基础情况：单个字符肯定是回文
            dp[i][i] = 1; 
            
            // 内层循环 j 代表子串的右边界
            for(int j = i + 1; j < n; j ++){
                // 状态转移逻辑：
                // 1. s[i] == s[j]：首尾必须相同
                // 2. (i + 1 > j - 1)：内部没有字符或只有一个字符（对应子串长度为 2 或 3）
                // 3. dp[i+1][j-1]：内部子串也是回文
                if (s[i] == s[j]) {
                    if (i + 1 > j - 1 || dp[i+1][j-1]) {
                        dp[i][j] = 1;
                    }
                }

                // 如果当前 [i, j] 是回文，且比之前记录的更长，则更新结果
                if(dp[i][j] && (j - i + 1) > maxlen){
                    max_i = i;
                    maxlen = j - i + 1;
                }
            }
        }
        
        // 根据记录的起始位置和长度截取字符串
        return s.substr(max_i, maxlen);
    }
};
```

