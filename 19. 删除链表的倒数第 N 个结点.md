# 19. 删除链表的倒数第 N 个结点

解题思路：快慢指针 + 哨兵节点

**1. 为什么要使用哨兵节点 (Dummy Node)？**
*   **统一逻辑**：如果不使用哨兵节点，当我们要删除的是**头节点**时（比如链表长度为 2，删除倒数第 2 个），我们需要写特殊的 `if` 逻辑。
*   **安全删除**：使用哨兵节点后，无论删除哪个节点，待删除节点一定有一个“前驱节点”。我们只需要让 `slow` 指针停在**待删除节点的前一个位置**，即可轻松执行 `slow->next = slow->next->next`。

**2. 核心数学逻辑：为什么快指针先走 $n+1$ 步？**
*   我们要删除倒数第 $n$ 个节点，最好的位置是停在倒数第 $n+1$ 个节点（即它的前驱）。
*   假设链表总长度为 $L$。
*   快指针先走 $n+1$ 步，剩下还要走 $L - (n+1)$ 步到达末尾的 `nullptr`。
*   此时慢指针开始走，当快指针到达 `nullptr` 时，慢指针也走了 $L - n - 1$ 步。
*   **结论**：从哨兵节点开始走 $L - n - 1$ 步，位置恰好就是倒数第 $n+1$ 个节点！

简洁版代码：

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* fast = dummy;
        ListNode* slow = dummy;
        // 快指针先走 n+1 步
        for(int i = 0; i <= n; i++) fast = fast->next;
        // 快慢指针同步走，当快指针到头，慢指针正好在待删除节点的前一个
        while(fast) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummy->next;

    }
};
```

注释版代码：

```
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // 1. 创建哨兵节点 dummy，指向 head。
        // 这是链表题的“保命符”，它确保了 head 也有前驱节点。
        ListNode* dummy = new ListNode(0, head);
        
        // 2. 初始化快慢指针，都指向哨兵节点。
        ListNode* fast = dummy;
        ListNode* slow = dummy;

        // 3. 快指针先走 n + 1 步。
        // 走 n 步是为了建立间距，多走 1 步是为了让 slow 最终停在待删除节点的前一个位置。
        for(int i = 0; i <= n; i++) {
            fast = fast->next;
        }

        // 4. 快慢指针同步向后移动。
        // 当 fast 走到链表末尾的 nullptr 时，slow 恰好就在倒数第 n 个节点的前面。
        while(fast != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }

        // 5. 执行删除操作。
        // 此时 slow->next 就是我们要删除的那个“倒数第 n 个节点”。
        // 我们让 slow 的 next 指向它下下个节点，直接跳过目标节点。
        ListNode* target = slow->next; // 暂存一下，方便后续可能的内存释放
        slow->next = slow->next->next;
        
        // delete target; // C++ 良好习惯：释放被删除节点的内存

        // 6. 返回真正的头节点。
        // 注意：不能直接返回 head，因为 head 也有可能被删除了。
        // dummy->next 永远指向当前链表真正的起始节点。
        ListNode* ret = dummy->next;
        delete dummy; // 释放哨兵节点的内存
        
        return ret;
    }
};
```

