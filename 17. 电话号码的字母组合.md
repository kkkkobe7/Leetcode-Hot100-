# 17. 电话号码的字母组合

解题思路拆解

**1. 建立映射表**
*   电话按键上，每个数字对应一组字母。我们需要先用数组或哈希表把这种映射关系存下来。
*   例如：`2 -> "abc"`, `3 -> "def"`。

**2. 核心逻辑：多路递归（回溯）**
*   **状态定义**：
    *   `k`: 当前处理到输入字符串 `digits` 的第几个数字。
    *   `s`: 当前已经拼接好的字母组合。
*   **决策过程**：
    1.  拿出当前数字 `digits[k]`。
    2.  查表找到它对应的字母列表（如 "abc"）。
    3.  **遍历**这些字母，把其中一个字母拼在 `s` 后面。
    4.  **递归**去处理下一个数字（`k + 1`）。
*   **终止条件**：
    *   当 `k` 等于 `digits` 的长度时，说明所有的数字都选好了字母，将当前的 `s` 存入结果集。

简洁版代码：

```c++
class Solution {
public:
    string map[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> ans;

    void dfs(int k, string s, string& digits) // 把digits[k]放在s后面
    {
        if (k == digits.size())
        {
            ans.push_back(s);
            return ;
        }
        int num = digits[k] - '0';
        int n = map[num].size();
        for (int i = 0; i < n; i ++)
        {
            dfs(k + 1, s + map[num][i], digits);
        }
        return ;
    }

    vector<string> letterCombinations(string digits) {
        dfs(0, "", digits);

        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 建立数字到字母的映射表
    string map[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> ans;

    // DFS 函数：从 digits 的第 k 位开始搜索
    void dfs(int k, string s, string& digits) 
    {
        // 1. 终止条件：当拼接的字符串长度等于输入的数字个数时，保存结果
        if (k == digits.size())
        {
            ans.push_back(s);
            return;
        }

        // 2. 获取当前数字对应的字母列表
        int num = digits[k] - '0';
        string letters = map[num];

        // 3. 遍历当前数字对应的所有可能字母
        for (int i = 0; i < letters.size(); i++)
        {
            // 将当前字母拼接到 s 后面，并递归处理下一个数字 (k + 1)
            // 这里使用 s + letters[i] 会产生一个新的字符串传递给下一层，
            // 这种写法隐式地完成了回溯的过程。
            dfs(k + 1, s + letters[i], digits);
        }
    }

    vector<string> letterCombinations(string digits) {
        // 从第 0 个数字开始搜索，初始字符串为空
        dfs(0, "", digits);

        return ans;
    }
};
```

