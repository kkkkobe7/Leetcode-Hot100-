# 141. 环形链表

### 解题思路拆解

**1. 初步直觉 (哈希表法 - 费空间)**

- 如果要判断一个地方我之前有没有来过，最直接的方法是用个本子记下来（哈希表/Set）。
- 每到一个节点，就查一下 Set 里有没有。如果有，说明有环；如果没有，就记进去。
- 但这种方法需要 `O(N)` 的空间。面试官通常会问：“能不能不用额外空间？”

**2. 物理隐喻 (赛跑模型)**

- 想象两个人在跑道上跑步。**情况 A（直道）：** 如果跑道是直的（无环），跑得快的人会直接到达终点，结束比赛。**情况 B（环形跑道）：** 如果跑道是一个圈（有环），跑得快的人迟早会**套圈**，从后面追上跑得慢的人。

**3. 算法设计 (快慢指针)**

- **角色设定：**slow (乌龟)：一次走 1 步。fast (兔子)：一次走 2 步。
- **开始比赛：** 两人都从起点 head 出发。
- **过程监控：**如果 fast 遇到了 nullptr（悬崖），说明链表有尽头，**无环**。如果 fast 追上了 slow（fast == slow），说明我们在一个圈里，**有环**。

**4. 为什么一定能相遇？**

- 这是一个数学问题。fast 每次比 slow 多走 1 步。
- 进入环后，可以看作 slow 不动，fast 以每次 1 格的速度在缩短它和 slow 的距离。
- 距离每次减 1，最终距离一定会变成 0（相遇），绝不会“跳过去”。

简洁版代码：

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow = head, *fast = head;

        while (fast && fast->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) return true;
        }

        return false;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // 定义两个指针，一开始都站在起跑线
        // slow: 慢指针，每次走一步
        // fast: 快指针，每次走两步
        ListNode* slow = head, *fast = head;

        // 循环条件：快指针必须有路可走
        // 1. fast != nullptr: 防止链表本身就是空的
        // 2. fast->next != nullptr: 因为 fast 要跳两步，所以下一步也不能是悬崖
        // 只要满足这两个条件，说明还没走到链表尽头
        while (fast && fast->next)
        {
            // 乌龟走一步
            slow = slow->next;
            // 兔子走两步
            fast = fast->next->next;
            
            // 核心判断：套圈了！
            // 如果快指针追上了慢指针，说明他们在环里绕圈圈
            if (slow == fast) return true;
        }

        // 如果循环结束了，说明 fast 走到了链表的尽头 (nullptr)
        // 既然有尽头，那就肯定不是环
        return false;
    }
};
```

