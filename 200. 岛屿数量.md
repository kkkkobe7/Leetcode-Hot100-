# 200. 岛屿数量

### 解题思路拆解

**1. 宏观策略：遍历与标记**

- 我们需要像扫描仪一样，逐行逐列地扫描整个二维网格。
- 当我们遇到一个 **'1' (陆地)** 时，我们需要判断：这块地之前来过吗？如果来过（vis 为 true），说明它属于我们之前已经统计过的某座岛屿，直接跳过。如果**没来过**，说明我们发现了**一座新的岛屿**！计数器 ans + 1。

**2. 核心操作：感染 (DFS/BFS)**

- 一旦发现了新岛屿的“登陆点”，我们必须立即启动搜索（这里用的是 DFS）。
- **任务目标：** 从这个登陆点出发，把所有和它相连的陆地全部找到，并标记为 vis = true。
- **为什么要做这一步？** 为了防止我们在后面的扫描中，重复计算这座岛屿的其他部分。

**3. 方向数组技巧**

- 怎么向四周搜索？通常我们需要写四个 if (上、下、左、右)。
- 为了代码优雅，我们引入 dx 和 dy 数组。通过循环 for(int i=0; i<4; i++) 配合这两个数组，就可以用统一的逻辑处理四个方向的坐标变化。



简洁版：

```c++
int n, m;
int ans;
bool vis[N][N];

int dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1, 0, 0};

void dfs(vector<vector<char>>& grid, int x, int y)
{
    vis[x][y] = true;

    for (int i = 0; i < 4; i ++)
    {
        int tx = x + dx[i], ty = y + dy[i];
        if (tx >= 0 && tx < n && ty >= 0 && ty < m && !vis[tx][ty] && grid[tx][ty] == '1')
            dfs(grid, tx, ty);
    }
}

int numIslands(vector<vector<char>>& grid) {
    n = grid.size(), m = grid[0].size();
    for (int i = 0; i < n ;i ++)
        for (int j = 0; j < m; j ++)
            if (!vis[i][j] && grid[i][j] == '1')
            {
                dfs(grid, i, j);
                ans ++;
            }

    return ans;
}
```



注释版：

```c++
class Solution {
public:
    // 定义最大范围，题目通常限制 grid 大小，310 足够了
    static const int N = 310;

    int n, m; // 网格的行数和列数
    int ans;  // 记录岛屿数量
    
    // 访问标记数组：记录某个坐标是否已经被统计过
    // 注意：在 LeetCode 中，如果是类成员变量，记得在函数入口处重置，否则多组测试用例会互相干扰
    bool vis[N][N];

    // 方向数组：配合使用可以得到 (x, y+1), (x, y-1), (x-1, y), (x+1, y)
    // 分别对应：右、左、上、下
    int dx[4] = {0, 0, -1, 1};
    int dy[4] = {1, -1, 0, 0};

    // 深度优先搜索 (DFS)
    // 功能：从 (x, y) 开始，把所有相连的陆地都标记为已访问
    void dfs(vector<vector<char>>& grid, int x, int y)
    {
        // 1. 标记当前点已访问，防止回头路死循环
        vis[x][y] = true;

        // 2. 向四个方向扩散
        for (int i = 0; i < 4; i ++)
        {
            // 计算新坐标
            int tx = x + dx[i], ty = y + dy[i];
            
            // 3. 边界与合法性检查 (非常重要！)
            // tx, ty 不能越界
            // !vis[tx][ty]: 必须是没访问过的
            // grid[tx][ty] == '1': 必须是陆地才能走过去
            if (tx >= 0 && tx < n && ty >= 0 && ty < m && !vis[tx][ty] && grid[tx][ty] == '1')
                dfs(grid, tx, ty); // 递归进入下一层
        }
    }

    int numIslands(vector<vector<char>>& grid) {
        n = grid.size();
        m = grid[0].size();
        
        // 【关键】初始化状态
        // LeetCode 的 C++ 类实例可能会被复用，所以每次调用主函数都要重置变量
        ans = 0; 
        memset(vis, 0, sizeof vis); // 将 vis 数组清零

        // 双重循环遍历每一个格子
        for (int i = 0; i < n ;i ++)
        {
            for (int j = 0; j < m; j ++)
            {
                // 如果当前点是陆地，且之前没有被访问过
                // 说明发现了一座“新岛屿”的根
                if (!vis[i][j] && grid[i][j] == '1')
                {
                    // 1. 把这座岛屿连根拔起（标记整座岛）
                    dfs(grid, i, j);
                    // 2. 岛屿数量 +1
                    ans ++;
                }
            }
        }

        return ans;
    }
};
```

