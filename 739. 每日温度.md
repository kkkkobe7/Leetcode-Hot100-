# 739. 每日温度

解题思路拆解

**1. 理解核心诉求**
我们需要对于每一天 `i`，找到它右边第一个索引 `j`，使得 `T[j] > T[i]`。我们需要记录的是距离 `j - i`。

**2. 暴力法的瓶颈**
*   对于每一天，都向后遍历直到找到更高的温度。
*   **坏情况**：如果是递减序列（如 `[99, 98, ..., 1]`），每次都要找很久，时间复杂度 $O(N^2)$。面对大数据量会超时。

**3. 循序渐进的推导 (单调栈)**
*   **逆向思维**：与其向后找“谁比我大”，不如我们**倒着遍历数组**。当我们站在第 `i` 天时，我们已经知道了 `i` 后面所有日子的信息。
*   **维护什么？** 我们需要一个容器（栈），里面存着未来日子的**索引**。
*   **淘汰机制（核心）：**
    *   假设我现在的温度是 75 度，我看向栈里存的未来日子。
    *   栈顶是 71 度？那 71 度肯定没用了。因为在未来的日子里，如果要找比 71 度高的，肯定也会先看到挡在前面的我（75 度）。所以把 71 扔掉（Pop）。
    *   栈顶是 69 度？扔掉。
    *   栈顶是 76 度？停！76 比我高，它就是离我最近的那个“更高温度”。
*   **入栈：** 处理完查询后，把自己（75 度）放进栈里，因为我也可能是更前面的日子的“更高温度”。
*   **单调性：** 因为比我小的都被扔掉了，留下的肯定比我大。所以栈里的温度从栈顶到底部是**单调递增**的。

**4. 为什么倒着遍历？**
*   倒着遍历时，右边的信息已经确定。
*   *(注：正序遍历也可以做，只是逻辑稍有不同，存的是“还没找到更高温度的日子”)*。



简洁版代码：

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n, 0);
        // 找到每一个元素后面第一个比其大的元素位置
        stack<int> st; // 单调栈
        st.push(n - 1);
        for (int i = n - 2; i >= 0; i --)
        {
            // 如果栈非空，且当前温度比栈顶更高，则弹出栈顶。
            while(!st.empty() && temperatures[i] >= temperatures[st.top()])
            {
                st.pop();
            }
            ans[i] = (st.empty())? 0: st.top() - i;
            st.push(i);
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        // 初始化结果数组，默认值为 0 (如果没有更高温度，保持 0)
        vector<int> ans(n, 0);
        
        // 单调栈：存储的是数组的索引（下标）
        // 特性：栈内索引对应的温度值，从栈顶到栈底是 单调递增 的
        stack<int> st; 
        
        // 我们选择倒序遍历（从右往左）
        // 先处理最后一天，把它放入栈中作为基准（虽然最后一天肯定没结果）
        st.push(n - 1);
        
        // 从倒数第二天开始向前遍历
        for (int i = n - 2; i >= 0; i --)
        {
            // 核心逻辑：比身高（淘汰机制）
            // 如果栈顶那一天的温度 <= 当前这天(i)的温度
            // 那么栈顶那一天对于 i 前面的日子来说，没有任何保留价值
            // 因为 i 挡在它前面，且 i 更高或一样高，找高温肯定先找到 i
            while(!st.empty() && temperatures[i] >= temperatures[st.top()])
            {
                st.pop(); // 矮个子出列，被挡住了
            }
            
            // 此时，如果栈不为空，栈顶就是右边第一个比当前温度高的日子
            // 计算距离：栈顶索引 - 当前索引
            // 如果栈空了，说明后面没有比我高的，保持 ans[i] 为 0
            ans[i] = (st.empty()) ? 0 : st.top() - i;
            
            // 处理完查询后，当前这天入栈，等待被更前面的日子查询
            st.push(i);
        }
        
        return ans;
    }
};
```

