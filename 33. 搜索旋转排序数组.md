# 33. 搜索旋转排序数组

定向分治法

**1. 核心发现：局部有序性**
在一个旋转排序数组中，从中间切开，**左半部分 `[st, mid]` 和右半部分 `[mid, end]` 中，一定至少有一个是严格升序排列的。**

**2. 决策逻辑：有序侧 vs 乱序侧**
*   **判断哪侧有序**：通过比较 `nums[st]` 和 `nums[mid]`。
    *   如果 `nums[st] < nums[mid]`，则左侧绝对有序。
    *   否则，断层在左侧，右侧 `[mid, end]` 绝对有序。
*   **判断 target 去向**：
    *   如果 `target` 落在**有序那一侧**的数值范围内，我们就不再需要递归了，直接对这一段调用标准的二分查找（即 `lower_bound`）。
    *   如果 `target` 不在有序侧的范围内，它只可能在另一侧的**乱序部分**，我们对那一半继续进行递归分解。

**3. 复杂度分析**
*   **时间复杂度**：$O(\log n)$。虽然看起来有递归，但每一层递归只进入了一个分支（要么执行 `lower_bound`，要么执行一次 `f`）。这本质上是将搜索范围减半。
*   **空间复杂度**：$O(\log n)$。递归调用栈的深度。

简洁版代码：

```c++
class Solution {
public:
    // O(log n)二分，每次二分，一半有序，一半不完全有序
    int f(vector<int>& nums, int st, int end, int target) // [st, end]
    {
        if (st == end) return nums[st] == target? st: -1;

        int mid = st + end >> 1;
        int ans = -1;
        if (nums[st] < nums[mid]) // mid左侧有序，右侧不完全
        {
            if (target <= nums[mid-1] && target >= nums[st]) // 在左侧
                ans = lower_bound(nums.begin()+st, nums.begin()+mid, target) - nums.begin(); // [st, mid)
            else // 在右侧
                ans = f(nums, mid, end, target); // [mid, end]
        }
        else
        {
            if (target <= nums[end] && target >= nums[mid+1]) // 在右侧
                ans = lower_bound(nums.begin()+mid+1, nums.begin()+end+1, target) - nums.begin(); // [mid+1, end]
            else // 在左侧
                ans = f(nums, st, mid, target); // [st, mid]
            
        }
        if (ans >= 0 && ans < nums.size() && nums[ans] == target) return ans;
        return -1;
    }

    int search(vector<int>& nums, int target) {
        return f(nums, 0, nums.size()-1, target);
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // f 函数：在旋转数组的 [st, end] 区间内寻找 target
    int f(vector<int>& nums, int st, int end, int target) 
    {
        // 1. 终止条件：区间只剩一个元素，直接看是不是 target
        if (st == end) return nums[st] == target ? st : -1;

        // 2. 取中点
        int mid = st + end >> 1;
        int ans = -1;

        // 3. 核心分支逻辑
        if (nums[st] < nums[mid]) 
        { 
            // 【左侧 [st, mid] 严格有序】
            
            // 检查 target 是否落在左侧有序区间的数值范围内
            // 这里判断 [st, mid-1] 是因为 mid 会在右侧递归中包含，或者通过逻辑覆盖
            if (target >= nums[st] && target <= nums[mid - 1]) 
            {
                // 如果在有序区，直接用 STL 的二分查找解决，不再递归
                ans = lower_bound(nums.begin() + st, nums.begin() + mid, target) - nums.begin();
            }
            else 
            {
                // 否则，target 只能在右侧的“乱序区”
                ans = f(nums, mid, end, target);
            }
        }
        else 
        {
            // 【右侧 [mid, end] 严格有序（或者左侧包含断层）】
            
            // 检查 target 是否落在右侧有序区间的数值范围内
            if (target >= nums[mid + 1] && target <= nums[end]) 
            {
                // 如果在右侧有序区，直接用二分查找
                ans = lower_bound(nums.begin() + mid + 1, nums.begin() + end + 1, target) - nums.begin();
            }
            else 
            {
                // 否则，target 只能在左侧的“乱序区”
                ans = f(nums, st, mid, target);
            }
        }

        // 4. 验证 lower_bound 或递归返回的结果是否有效
        // 只有下标合法且对应值等于 target 才是我们要找的答案
        if (ans >= 0 && ans < nums.size() && nums[ans] == target) return ans;
        
        return -1;
    }

    int search(vector<int>& nums, int target) {
        if (nums.empty()) return -1;
        return f(nums, 0, nums.size() - 1, target);
    }
};
```

