# 分割等和子集

解题思路拆解

**1. 问题转化**
*   题目问：能不能把数组分成两半，让两边的和相等？
*   设整个数组的和为 `Sum`。
*   如果有解，说明每一边的和都必须是 `Sum / 2`。
*   **转化：** 能否从数组中挑选出一些数，让它们的和**恰好**等于 `Sum / 2`？

**2. 快速判断（剪枝）**
*   如果 `Sum` 是奇数，肯定没法平分，直接返回 `false`。

**3. 建模：0/1 背包**
*   **背包容量：** `Target = Sum / 2`。
*   **物品：** 数组里的每个数字。
*   **规则：** 每个数字只能用一次（0/1 背包）。
*   **目标：** 背包能不能被**刚好填满**？（或者说，填满背包的最大价值是不是等于背包容量本身？在您的代码中直接用 `bool` 表示是否可达）。

**4. 状态定义**
*   `f[j]`: 布尔值。表示容量为 `j` 的背包，**能否**被恰好填满。

**5. 状态转移**
*   对于当前数字 `num`：
    *   如果不选它：状态不变，还是 `f[j]`。
    *   如果选它：只要 `f[j - num]` 是 true，那么 `f[j]` 也就变成 true 了。
*   `f[j] = f[j] || f[j - num]`。

简洁版代码：

```c++
class Solution {
public:
    static const int N = 110;
    bool f[N*N]; // 体积为sum/2的0/1背包问题

    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (auto& num: nums) sum += num;
        if (sum % 2) return false;

        int v = sum / 2;
        f[0] = true;
        for (auto& num: nums)
        {
            for (int j = v; j >= num; j --)
            {
                f[j] = f[j] || f[j - num];
                if (f[v]) return true;
            }
        }
        return f[v];
        
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 定义：根据题目提示，nums.length <= 200, nums[i] <= 100
    // 所以 sum 最大为 200 * 100 = 20000。
    // sum / 2 最大为 10000。
    // N*N = 12100，是够用的。更精准的写法是直接定义 MAX_TARGET = 10010。
    static const int N = 110;
    
    // DP 数组：f[j] 表示是否能凑出和为 j
    // 【关键】类成员变量建议在函数内初始化，防止多测污染
    bool f[N*N]; 

    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (auto& num: nums) sum += num;
        
        // 1. 剪枝：如果总和是奇数，不可能平分
        if (sum % 2 != 0) return false;

        // 目标：凑出 sum / 2
        int v = sum / 2;
        
        // 2. 初始化
        // 【重要】清空数组，尤其是 LeetCode 类成员变量复用的情况下
        memset(f, 0, sizeof f); 
        
        // Base Case: 凑出 0 元不需要任何数字，肯定是可以的
        f[0] = true;

        // 3. 动态规划 (0/1 背包)
        // 外层循环：遍历每一个物品 (数字)
        for (auto& num: nums)
        {
            // 内层循环：遍历背包容量
            // 【关键】必须倒序遍历！ (从 v 到 num)
            // 因为我们使用的是一维数组，倒序遍历保证了计算 f[j] 时，
            // f[j - num] 还是上一轮(即不包含当前 num)的状态。
            // 如果正序，f[j-num] 可能已经被更新过(包含了 num)，导致 num 被重复使用。
            for (int j = v; j >= num; j --)
            {
                // 状态转移：要么本身就能凑出来(不选num)，要么靠之前的凑(选num)
                f[j] = f[j] || f[j - num];
                
                // 【剪枝优化】
                // 如果发现 f[v] 已经是 true 了，说明已经凑出目标值了
                // 没必要继续算后面的数字了，直接返回
                if (f[v]) return true;
            }
        }
        
        return f[v];
    }
};
```

