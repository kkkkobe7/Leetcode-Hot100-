# 448. 找到所有数组中消失的数字

**进阶：**你能在不使用额外空间且时间复杂度为 `O(n)` 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

 解题思路拆解

**1. 核心洞察：鸽巢原理 (Pigeonhole Principle)**
*   我们有 `n` 个坑位（索引 `0` 到 `n-1`）。
*   我们有 `n` 个数字，范围是 `1` 到 `n`。
*   理想情况下，数字 `k` 应该乖乖地坐在索引 `k-1` 的位置上。（比如数字 1 坐在 nums[0]，数字 5 坐在 nums[4]）。

**2. 核心操作：归位 (Cycle Sort 思维)**
*   我们遍历数组，对于每一个位置 `i` 上的数字 `x = nums[i]`：
    *   看看 `x` 是否坐在它该坐的位置（即索引 `x-1`）？
    *   如果不坐，那索引 `x-1` 上的那个家伙是谁？
    *   如果那个家伙也是 `x`（比如我有两个 3），说明重复了，不管它，继续下一个。
    *   如果那个家伙不是 `x`，那就把它俩**交换 (swap)**。把 `x` 放到它该去的地方，把那个位置原来的数字换过来。
    *   换过来的新数字可能还是没坐对，所以要用 `while` 循环一直换，直到当前位置坐对了人，或者换回来的数字是重复的废弃值。

**3. 最后的清点**
*   经过一轮激烈的交换，所有“能归位”的数字都归位了。
*   现在再次遍历数组：
    *   如果 `nums[i]` 坐的是 `i+1`，说明 `i+1` 出现了。
    *   如果 `nums[i]` 坐的不是 `i+1`（比如坐了个重复的别人的数字），说明 **`i+1` 这个数字在原数组里压根没出现过**（没人来认领这个座位）。
    *   记录下所有空座位的编号。

简洁版代码：

```c++
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0 ; i < n; i ++)
        {
            while (nums[nums[i]-1] != nums[i]) swap(nums[i], nums[nums[i] - 1]); // 看看其应该在的位置是否放着应该有的元素（如果有，nums[i]为重复；否则换位）
        }
        
        vector<int> ans;
        for (int i = 0; i < n; i ++)
        {
            if (nums[i] != i + 1) // 错误位置的数字就是漏掉的数字
                ans.push_back(i + 1);
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        
        // 1. 归位阶段 (Cycle Sort)
        // 目标：尽可能把数字 x 放到 nums[x-1] 的位置上
        for (int i = 0 ; i < n; i ++)
        {
            // 当前位置 i 坐着的数字是 nums[i]
            // 这个数字原本应该坐的位置是索引 nums[i] - 1
            // 检查：如果那个位置上坐的不是正确的数字 (即 nums[nums[i]-1] != nums[i])
            // 那么我们就进行交换，把 nums[i] 送回老家
            while (nums[nums[i]-1] != nums[i]) 
            {
                // 交换 nums[i] 和 nums[nums[i]-1]
                // 把 nums[i] 放到它该在的地方
                // 同时把那个位置原来的数字换到 i 这里来，等待下一轮 while 检查处理
                swap(nums[i], nums[nums[i] - 1]); 
            }
        }
        
        // 2. 清点阶段
        vector<int> ans;
        for (int i = 0; i < n; i ++)
        {
            // 检查：位置 i 上坐的应该是数字 i+1
            // 如果坐的不是 i+1，说明 i+1 这个数字在整个数组中缺失了
            // (并且这个位置被某个多余的重复数字占据了)
            if (nums[i] != i + 1) 
                ans.push_back(i + 1);
        }
        
        return ans;
    }
};
```

