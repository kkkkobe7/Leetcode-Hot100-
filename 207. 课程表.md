# 207. 课程表

**图的拓扑排序问题**

解题思路拆解

**1. 建模：把现实问题转化为图论**
*   **节点（Node）：** 每一门课程就是一个节点。
*   **有向边（Edge）：** “先修课程”决定了方向。如果修课程 0 必须先修 1，那么就有一条边 `1 -> 0`（1 指向 0）。
*   **核心问题：** 我们是否能修完所有课？换句话说，**图中是否存在“环”**？
    *   如果存在 `A -> B -> A` 这样的环，谁也无法开始，任务失败。
    *   只要是有向无环图（DAG），我们就一定能修完。

**2. 寻找突破口：入度（In-degree）**
*   想象一下，你要开始修课，第一门课必须选什么？
*   当然是**没有任何先修要求**的课程！
*   在图论中，这对应**入度为 0** 的节点。

**3. 循序渐进的推导 (Kahn 算法)**
*   **第一步：** 统计所有课程的“入度”（即有多少门课指向它）。
*   **第二步：** 把所有“入度为 0”的课程（可以直接修的课）放进一个**队列**。
*   **第三步：** 开始“修课”（BFS 过程）：
    1.  从队列拿出一门课（修完了）。
    2.  找到这门课的所有“后继课程”（它指向的节点）。
    3.  把这些后继课程的入度减 1（代表它们的一门先修课已经搞定了）。
    4.  **关键点：** 如果某个后继课程的入度变成了 0，说明它的所有先修课都修完了，把它加入队列。
*   **第四步：** 判定结果。如果最后所有出现在依赖关系里的课程都被我们“修完”了（队列处理完了），则成功；如果还有课程剩下来（入度不为0，进不了队列），说明有环，失败。



简洁版代码：

```c++
class Solution {
public:
    static const int N = 2010;
    unordered_map<int, vector<int>> g; // 出边
    unordered_set<int> cc; // 所有课程
    int d[N]; // 入度

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        if (prerequisites.size() == 0) return true;

        for (auto p: prerequisites)
        {
            if (p[0] == p[1]) return false; // 图中出现子环
            if (g.find(p[1]) == g.end()) g.find(p[1]) = {}; // 若节点第一次出现，初始化
            g[p[1]].push_back(p[0]);
            d[p[0]] ++; // 入度++
            cc.insert(p[0]);
            cc.insert(p[1]);
        }

        queue<int> q; // 利用队列遍历所有入度为0的点
        for (auto c: cc)
            if (d[c] == 0) q.push(c);
        
        if (q.empty()) return false;
        
        while (!q.empty()) // 对于每个入度为0的点进行遍历，移除其所有出边，并将更新后度为0的点加入队列
        {
            int course = q.front();
            q.pop();
            cc.erase(course);

            for (auto& c: g[course])
            {
                if (-- d[c] == 0) 
                    q.push(c);
            }
        }
        return cc.empty();
        
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 定义最大课程数量，用于数组大小
    static const int N = 2010;
    
    // 邻接表：存储图结构
    // key: 当前课程, value: 依赖于当前课程的后续课程列表 (即当前课程指向的节点)
    unordered_map<int, vector<int>> g; 
    
    // 集合：用来记录所有在 prerequisites 中出现过的课程
    // 作用是最后用来判断是否所有涉及依赖的课程都被处理掉了
    unordered_set<int> cc; 
    
    // 入度数组：d[i] 表示课程 i 还有多少门先修课没完成
    int d[N]; 

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 特判：如果没有先修课要求，直接可以完成
        if (prerequisites.size() == 0) return true;

        // 1. 建图 & 统计入度
        for (auto p: prerequisites)
        {
            // p[0] 是后续课程，p[1] 是先修课程，方向 p[1] -> p[0]
            
            // 简单剪枝：如果自己依赖自己，直接构成死循环，返回 false
            if (p[0] == p[1]) return false; 
            
            // 注意：在标准 C++ 中，g[p[1]] 会自动创建空 vector，无需手动 find 判断
            // 这里意为：如果 p[1] 第一次出现，确保它在 map 中初始化
            if (g.find(p[1]) == g.end()) g[p[1]] = {}; 
            
            // 建立边：p[1] -> p[0]
            g[p[1]].push_back(p[0]);
            
            // p[0] 的入度 +1
            d[p[0]] ++; 
            
            // 将涉及到的课程加入集合 cc，用于最后比对
            cc.insert(p[0]);
            cc.insert(p[1]);
        }

        // 2. 初始化队列
        queue<int> q; 
        // 遍历所有涉及的课程，找到第一批可以直接学的课（入度为 0）
        for (auto c: cc)
            if (d[c] == 0) q.push(c);
        
        // 如果有依赖关系，但没有一个入度为 0 的点，说明全是环，直接失败
        if (q.empty()) return false;
        
        // 3. BFS 拓扑排序
        while (!q.empty()) 
        {
            int course = q.front();
            q.pop();
            
            // 每修完一门课，就从集合 cc 中移除它
            // 只有无环图，所有节点才能最终被移除
            cc.erase(course);

            // 遍历这门课的所有后续课程（出边）
            for (auto& c: g[course])
            {
                // 将后续课程的入度减 1 (代表搞定了一个先修课)
                // 如果减完后入度变为 0，说明该后续课程也可以修了，加入队列
                if (--d[c] == 0) 
                    q.push(c);
            }
        }
        
        // 4. 结果判断
        // 如果集合为空，说明所有有依赖关系的课程都修完了 -> True
        // 如果集合不为空，说明剩下的课程构成了环，无法入队 -> False
        return cc.empty();
    }
};
```

