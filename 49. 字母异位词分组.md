# 49. 字母异位词分组

解题思路拆解

**1. 定义“字母异位词”的特征**
*   两个单词互为字母异位词 $\Leftrightarrow$ 它们包含的字母种类和每个字母出现的次数完全相同。
*   **方法 A：排序法**。将单词按字母顺序排序，如 "eat", "tea", "ate" 排序后都变成 "aet"。这是最常用的 Key。
*   **方法 B：计数法（采用的解法）**。统计 26 个字母出现的频率。如 "eat" 的频率是 `{a:1, e:1, t:1}`，其他字母为 0。

**2. 核心逻辑：特征映射**
*   我们遍历每一个单词 `s`。
*   **提取指纹**：计算 `s` 的字母分布情况。
*   **建立映射**：使用哈希表 `map` 记录某种“指纹”对应的**类别编号**（或者直接对应单词列表）。
*   **归类**：如果是第一次见这个指纹，给它分配一个新的编号 `idx`；如果是见过的指纹，直接把单词塞进对应的组里。

**3. 您的代码亮点：字符计数作为指纹**
*   您使用了一个长度为 26 的字符串 `cur` 作为 Key。
*   `cur[0]` 存储 'a' 的数量，`cur[1]` 存储 'b' 的数量…… 
*   这种方法比“排序法”在处理超长字符串时效率更高，因为统计频率是 $O(L)$，而排序是 $O(L \log L)$。



简洁版代码：

```c++
class Solution {
public:
    unordered_map<string, int> map;
    static const int N = 1e4 + 10;
    int a[N], idx = 0; // idx表示类别数
    string de = "00000000000000000000000000";

    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        int n = strs.size();

        for (int i = 0; i < n; i ++)
        {
            string s = strs[i];
            string cur = de;
            for (auto& c: s) cur[c - 'a'] = cur[c - 'a'] + 1;
            if (map.find(cur) == map.end())
            {
                map[cur] = idx;
                a[i] = idx ++;
            }
            else
            {
                a[i] = map[cur];
            }
        }
        vector<vector<string>> ans(idx, vector<string>());
        for (int i = 0; i < n; i ++)
            ans[a[i]].push_back(strs[i]);
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // map: Key 是字母频率特征字符串，Value 是该类别的组编号 (0, 1, 2...)
    unordered_map<string, int> map;
    
    static const int N = 1e4 + 10;
    // a[i] 记录第 i 个单词所属的类别编号
    int a[N], idx = 0; 
    
    // 初始指纹：26个'0'，代表 26 个字母初始计数都为 0
    string de = "00000000000000000000000000";

    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        int n = strs.size();
        // 记得在多用例环境下重置全局变量
        map.clear();
        idx = 0;

        // 第一遍扫描：计算特征并分类
        for (int i = 0; i < n; i ++)
        {
            string s = strs[i];
            string cur = de; // 拷贝初始指纹
            
            // 核心步骤：统计每个字母出现的次数
            // 比如 s="aba"，则 cur[0] 变成 '2' (ASCII), cur[1] 变成 '1'
            for (auto& c: s) cur[c - 'a'] ++;
            
            // 判断这种特征是否出现过
            if (map.find(cur) == map.end())
            {
                // 新特征：分配新编号，并存入 map
                map[cur] = idx;
                a[i] = idx ++;
            }
            else
            {
                // 旧特征：直接获取编号
                a[i] = map[cur];
            }
        }

        // 第二遍扫描：根据编号将单词放入对应的 vector 中
        vector<vector<string>> ans(idx, vector<string>());
        for (int i = 0; i < n; i ++)
            ans[a[i]].push_back(strs[i]);
            
        return ans;
    }
};
```

