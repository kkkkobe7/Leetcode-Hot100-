# 226. 反转二叉树

解题思路拆解

**1. 函数定义的升华**
不要只把函数 `lowestCommonAncestor` 看作“找 LCA”。
在递归过程中，它的实际含义是：**“在以 `root` 为根的子树中，寻找 `p` 或 `q`。”**
*   如果找到了 `p`，就返回 `p`。
*   如果找到了 `q`，就返回 `q`。
*   如果两个都找到了（即它们分别在两边），那就返回当前的 `root`（它是 LCA）。
*   如果都没找到，返回 `nullptr`。

**2. 递归的终止条件（Base Case）**
什么时候不需要再往下找了？
*   **走到尽头：** `root` 为空，肯定是找不到了，返回 `nullptr`。
*   **找到目标：** `root` 刚好就是 `p` 或者 `q`。
    *   *关键点：* 比如我找到了 `p`，我还需要去 `p` 的下面找 `q` 吗？**不需要**。
    *   如果 `q` 在 `p` 的下面，那 `p` 就是 LCA，直接返回 `p` 没问题。
    *   如果 `q` 在别的地方，把 `p` 传上去给父节点处理即可。

**3. “分”与“合”的逻辑**
*   **分（Divide）：** 让左子树去找，让右子树去找。
*   **合（Conquer）：** 也就是“面试官”最看重的逻辑判断部分。
    *   **情况 A（左右都有）：** 左边回报“找到了”，右边也回报“找到了”。说明 `p` 和 `q` 分居在当前 `root` 的两侧。那么**当前 `root` 就是最近公共祖先**。
    *   **情况 B（只有一边有）：** 左边回报“找到了”，右边是空的。说明 `p` 和 `q` 都在左子树里（或者其中一个是另一个的祖先，且都在左边）。直接向上返回左边的结果。
    *   **情况 C（都没找到）：** 返回空。



简洁版代码：

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == nullptr || (root->left == nullptr && root->right == nullptr)) return root;
        TreeNode* l = invertTree(root->left);
        TreeNode* r = invertTree(root->right);
        root->left = r;
        root->right = l;
        return root;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 函数定义：在以 root 为根的树中，寻找 p 和 q
    // 返回值：
    // 1. 如果 p 和 q 都在这棵树下，返回最近公共祖先
    // 2. 如果只有 p 在，返回 p
    // 3. 如果只有 q 在，返回 q
    // 4. 都不在，返回 nullptr
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        
        // ------------------------------------------------
        // 1. 递归终止条件 (Base Case)
        // ------------------------------------------------
        
        // 如果越过叶子节点（root为空），说明没找到，返回空
        if (root == nullptr) return nullptr;
        
        // 如果当前节点就是 p 或者 q，说明找到了其中一个
        // 直接返回当前节点，不需要再往下面递归了
        // (即使另一个节点在下面，当前节点也是它们的 LCA)
        if (root == p || root == q) return root;

        // ------------------------------------------------
        // 2. 递 (Divide) - 去左右子树寻找
        // ------------------------------------------------
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        // ------------------------------------------------
        // 3. 归 (Conquer) - 根据结果判断 LCA
        // ------------------------------------------------
        
        // 情况 1: 左右子树都有结果
        // 意味着 p 在一边，q 在另一边
        // 那么当前 root 就是它们的“分岔口”，即最近公共祖先
        if (left != nullptr && right != nullptr) {
            return root;
        }

        // 情况 2 & 3: 只有一边有结果 (或者两边都没结果)
        // 如果 left 不为空，说明目标都在左子树，返回 left
        // 如果 left 为空，right 不为空，说明目标都在右子树，返回 right
        // 如果都为空，right 也是空，返回空
        return left ? left : right;
    }
};
```

