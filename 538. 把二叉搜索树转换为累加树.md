# 538. 把二叉搜索树转换为累加树

解题思路：反向中序遍历的“滚雪球”效应

**1. 核心洞察：倒着数数**
*   二叉搜索树（BST）的中序遍历（左-根-右）结果是 **从小到大**。
*   如果我们将中序遍历反过来，即 **（右-根-左）**，结果就是 **从大到小**。
*   比如一个 BST 的值是 `[2, 5, 13]`，反向中序遍历的顺序就是 `13 -> 5 -> 2`。

**2. 累加逻辑：雪球越滚越大**
*   我们要把所有“大于等于当前节点”的值加起来。
*   如果我们按照 **从大到小** 的顺序走：
    *   第一个遇到的节点（最大的，13）没有比它更大的了，新值就是 `13`。
    *   第二个遇到的节点（5）比它大的只有刚才那个 `13`，所以新值是 `5 + 13 = 18`。
    *   第三个遇到的节点（2）比它大的有 `13` 和 `5`，所以新值是 `2 + 18 = 20`。
*   **结论**：我们只需要维护一个全局累加变量 `sum`，每经过一个节点，就把当前值加进去，并更新当前节点即可。

**3. 递归三部曲**
*   **第一步（右）**：先递归最右子树，找到这棵树里最大的那一堆。
*   **第二步（根）**：处理当前节点。把当前值累加进 `sum`，然后把 `sum` 赋给当前节点。
*   **第三步（左）**：带着最新的 `sum` 递归左子树，处理那些比当前节点小的节点。

简洁版代码：

```c++
class Solution {
public:
    int sum = 0; // 当前已经处理过的所有较大节点的累加和

    void traverse(TreeNode* root) {
        if (!root) return;

        traverse(root->right);

        sum += root->val; // 将当前节点值累加
        root->val = sum;  // 更新当前节点

        traverse(root->left);
    }

    TreeNode* convertBST(TreeNode* root) {
        sum = 0;
        traverse(root);
        return root;
    }
};
```

注释版代码：

```
class Solution {
public:
    int sum = 0; // 全局记录：当前已经处理过的所有较大节点的累加和

    void traverse(TreeNode* root) {
        if (!root) return;

        // 1. 右：先去最右边找最大的
        traverse(root->right);

        // 2. 根：处理当前节点
        sum += root->val; // 将当前节点原值加到累加器中
        root->val = sum;  // 更新当前节点为新的累加值

        // 3. 左：带着累加后的 sum 去处理更小的左子树
        traverse(root->left);
    }

    TreeNode* convertBST(TreeNode* root) {
        sum = 0;
        traverse(root);
        return root;
    }
};
```

