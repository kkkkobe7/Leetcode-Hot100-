# 283. 移动零

解题思路拆解

我们可以把这道题想象成：**“把所有非零元素按顺序‘挤’到数组的前面。”**

**1. 核心模型：快慢指针**
*   **慢指针 (`p`)**：指向“下一个非零元素应该存放的位置”。
*   **快指针 (`i`)**：用来扫描整个数组，寻找非零元素。

**2. 贪心策略**
*   我们从左到右扫描数组。
*   只要遇到一个 **非零元素**：
    *   我们就把它和 `p` 指向的位置交换。
    *   交换后，`p` 向后移动一位，等待下一个非零元素。
*   **为什么这能成功？**
    *   因为 `p` 永远不会走在快指针前面。
    *   如果数组前面全是正常的数字，`p` 和快指针会重合，交换相当于自己换自己。
    *   一旦遇到了 `0`，`p` 就会停在 `0` 的位置上，而快指针继续向后找。当快指针找到下一个非零数时，一交换，就把 `0` 换到了后面，非零数换到了前面。

**3. 相对顺序的保证**
*   因为我们是从左到右顺序扫描快指针的，所以非零元素被“填入”前面位置的顺序也是它们原本出现的顺序。



简洁版代码：

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // p 指针：代表“下一个非零元素要存放的位置”
        int p = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            // 只要发现当前元素不是0，就将其交换到 p 指向的位置
            if (nums[i] != 0) {
                swap(nums[p], nums[i]);
                p++;
            }
        }
    }
};
```

注释版代码：

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // p 指针：代表“下一个非零元素要存放的位置”
        int p = 0;
        
        // i 指针：快指针，遍历整个数组
        for (int i = 0; i < nums.size(); i++) {
            // 只要发现当前元素不是 0
            if (nums[i] != 0) {
                // 将其交换到 p 指向的位置
                // 注意：如果 i 和 p 相等（即还没遇到过0），swap 相当于什么都没做
                swap(nums[p], nums[i]);
                
                // p 往后挪，为下一个非零元素腾出位置
                p++;
            }
        }
    }
};
```

