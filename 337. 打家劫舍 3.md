# 337. 打家劫舍 3

解题思路拆解

**1. 核心矛盾：选还是不选？**
*   对于树中的任意一个节点（房子），小偷只有两种状态：**偷** 或者 **不偷**。
*   **约束条件：** 两个直接相连的房子不能同时偷。这意味着：
    *   如果偷了父节点，左右两个子节点都**绝对不能**偷。
    *   如果不偷父节点，左右子节点**可以偷，也可以不偷**（选收益大的那种情况）。

**2. 状态定义 (State Definition)**
*   为了让父节点做决定，每个子节点必须汇报两个信息。
*   我们定义一个 `pair<int, int>` 作为递归返回值：
    *   `first`: **偷**当前节点时，所能获得的最大收益。
    *   `second`: **不偷**当前节点时，所能获得的最大收益。

**3. 递推逻辑 (Transition)**
我们要从叶子节点往根节点推导（**后序遍历**）：
*   **偷当前节点 (`rob_cur`)：**
    *   收益 = 当前节点的值 + 左孩子不偷的收益 + 右孩子不偷的收益。
    *   公式：`root->val + left.second + right.second`
*   **不偷当前节点 (`not_rob_cur`)：**
    *   收益 = 左孩子能给的最大收益（偷或不偷选大的） + 右孩子能给的最大收益。
    *   公式：`max(left.first, left.second) + max(right.first, right.second)`

**4. 初始状态 (Base Case)**
*   如果遇到空节点 (`nullptr`)，不管偷不偷，收益都是 0。返回 `{0, 0}`。



简洁版代码：

```c++
class Solution {
public:
    // 树的递推，当前节点选，则两个子节点不能选
    // 当前节点不选，则两个子节点可以选可以不选
    // 用pair<int, int>存储，first表达选，second表示不选
    pair<int, int> post_order(TreeNode* root)
    {
        if (root == nullptr) return {0, 0};
        if (root->left == nullptr && root->right == nullptr) return {root->val, 0};

        pair<int, int> left = post_order(root->left);
        pair<int, int> right = post_order(root->right);

        // 如果选当前，则两个子节点都不能选；如果不选当前，两个子节点可选可不选，选大的
        return {root->val + left.second + right.second, max(left.first, left.second) + max(right.first, right.second)};
    }

    int rob(TreeNode* root) {
        pair<int, int> ans = post_order(root);
        return max(ans.first, ans.second);
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 辅函数：后序遍历（自底向上）
    // 返回 pair<int, int>：
    // first 代表偷当前节点的最大金额，second 代表不偷当前节点的最大金额
    pair<int, int> post_order(TreeNode* root)
    {
        // 1. 基础情况：空节点，偷不偷都是 0
        if (root == nullptr) return {0, 0};
        
        // 2. 基础情况：叶子节点（可选优化，不加也没事，通用逻辑能覆盖）
        // 如果偷：收益是 root->val；如果不偷：收益是 0
        if (root->left == nullptr && root->right == nullptr) return {root->val, 0};

        // 3. 递归：先去拿左右子树的结果（后序遍历的核心）
        pair<int, int> left = post_order(root->left);
        pair<int, int> right = post_order(root->right);

        // 4. 计算当前节点两种选择的结果
        
        // 选择 A：偷当前节点
        // 那么左右孩子都必须处于“不偷”的状态（即 left.second 和 right.second）
        int rob_this = root->val + left.second + right.second;
        
        // 选择 B：不偷当前节点
        // 那么左右孩子爱偷不偷，我们分别从它们的结果中选个最大的加起来
        int not_rob_this = max(left.first, left.second) + max(right.first, right.second);

        // 5. 返回当前层的结果给父节点
        return {rob_this, not_rob_this};
    }

    int rob(TreeNode* root) {
        // 从根节点开始进行树形 DP
        pair<int, int> ans = post_order(root);
        
        // 最终结果是根节点“偷”与“不偷”中的最大值
        return max(ans.first, ans.second);
    }
};
```

