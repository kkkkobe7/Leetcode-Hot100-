# 42. 接雨水

解题思路拆解

**1. 核心原理：木桶效应**
*   每一根柱子上能接多少水，取决于它**左边最高的墙**和**右边最高的墙**。
*   公式：`当前格子的水量 = min(左边最高, 右边最高) - 当前柱子高度`。

**2. 暴力法的痛点**
*   如果我们对每一根柱子都去左右扫描找最高墙，时间复杂度是 $O(N^2)$。
*   如果我们先用数组预处理出每根柱子的 `left_max` 和 `right_max`，空间复杂度是 $O(N)$。

**3. 本解法的巧妙之处：找到“最高峰”**
*   **第一步**：找到全场最高的柱子，记为 `id`。
*   **第二步：处理最高峰左侧**。
    *   由于右边已经有一个全场最高的“大山”顶着了，所以左侧任何一根柱子的“右边最高墙”一定大于等于它自己。
    *   **结论**：左侧柱子能接多少水，**只取决于它左边的最高墙**。
*   **第三步：处理最高峰右侧**。
    *   同理，由于左边有全场最高峰顶着，右侧柱子能接多少水，**只取决于它右边的最高墙**。

**4. 总结**
通过找到最高点，我们将一个复杂的“左右夹击”问题，转化成了两个简单的“单向扫描”问题。



简洁版代码：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size(), id = 0, ans = 0;
        for (int i = 0; i < n; i ++) // 找到最高点
            if (height[i] > height[id])
                id = i;

        int l = height[0];
        for (int i = 1; i < id; i ++) // 在最高点左侧的柱子，只需要考虑其左侧的最大值
        {
            if (height[i] < l) ans += l - height[i];
            else l = height[i];
        }

        l = height[n - 1];
        for (int i = n - 1; i >= id; i --) // 在最高点右侧的柱子，只需要考虑其右侧的最大值
        {
            if (height[i] < l) ans += l - height[i];
            else l = height[i];
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n <= 2) return 0; // 只有两根或更少柱子，接不到水

        // 1. 寻找全场最高点的下标 id
        int id = 0;
        for (int i = 0; i < n; i ++) {
            if (height[i] > height[id])
                id = i;
        }

        int ans = 0;

        // 2. 处理最高点左侧 [0, id)
        // l 记录当前扫描过程中，左侧出现的最高墙的高度
        int l = height[0];
        for (int i = 1; i < id; i ++) 
        {
            // 如果当前的墙比左边最高墙 l 矮，说明可以接水
            if (height[i] < l) {
                ans += l - height[i]; // 水面高度被 l 限制
            } 
            // 如果当前的墙比 l 高，更新左侧最高墙
            else {
                l = height[i];
            }
        }

        // 3. 处理最高点右侧 (id, n-1]
        // 同样，r 记录右侧出现的最高墙的高度
        int r = height[n - 1];
        for (int i = n - 1; i > id; i --) 
        {
            // 如果当前的墙比右边最高墙 r 矮，可以接水
            if (height[i] < r) {
                ans += r - height[i]; // 水面高度被 r 限制
            } 
            // 如果当前的墙比 r 高，更新右侧最高墙
            else {
                r = height[i];
            }
        }

        return ans;
    }
};
```

