# 208. 实现Trie（前缀树）

解题思路拆解

**1. 什么是 Trie（前缀树）？**
*   想象查字典。你要查 "apple"，你会先翻到 'a' 的部分，再在 'a' 下面找 'p'，再找 'p'...
*   Trie 就是把这个过程具象化：
    *   **根节点**是空的。
    *   每个节点有 **26 条岔路**（对应 'a' - 'z'）。
    *   如果走这条路，就进入下一个节点。

**2. 核心数据结构设计**
*   **节点表示：** 我们不用 `struct Node`，而是用一个整数 `p` 代表节点编号。`0` 号通常作为根节点。
*   **路径存储 (`son` 数组)：**
    *   `son[p][u]` 表示：节点 `p` 的第 `u` 个孩子（字符）所在的节点编号。
    *   例如 `son[0][0] = 1` 意味着：根节点经过 'a' (0号字符) 到达了 1 号节点。
    *   如果 `son[p][u] == 0`，说明没路了，不存在这个前缀。
*   **单词结尾标记 (`cnt` 数组)：**
    *   树里存了 "apple"，也能查到 "app"，但 "app" 是存进去的单词吗？
    *   我们需要给节点打个标。`cnt[p] = true` 表示节点 `p` 是某个单词的终点。

**3. 三大操作逻辑**
*   **Insert (插入)：** 从根开始，顺着字符走。如果路不存在，就新建一个节点（`++idx`），把路连上。走到最后，在终点打个勾 (`cnt[p] = true`)。
*   **Search (查找单词)：** 从根开始走。如果中间路断了，直接 `false`。如果顺利走完，检查终点有没有打勾。
*   **StartsWith (查找前缀)：** 和查找单词完全一样，唯一的区别是：**只要能顺着路走完就行**，不需要管终点有没有打勾。



简洁版代码：

```c++
class Trie {
public:
    static const int N = 300010;

    int son[N][26]; // 每个节点的孩子节点
    bool cnt[N]; // 以当前点为结尾的单词有多少个
    int idx = 0; 
    // 此处下标是0的点，既是根结点，又是空节点

    Trie() {
        for (int i = 0; i < N; i ++)
            for (int j = 0; j < 26; j ++)
                son[i][j] = 0;
    }
    
    void insert(string word) {
        int p = 0, n = word.size();
        for (int i = 0; i < n; i ++)
        {
            int u = word[i] - 'a';
            if (son[p][u] == 0) son[p][u] = ++ idx;
            p = son[p][u];
        }
        cnt[p] = true;
        return ;
    }
    
    bool search(string word) {
        int p = 0, n = word.size();
        for (int i = 0; i < n; i ++)
        {
            int u = word[i] - 'a';
            if (!son[p][u]) return false;
            p = son[p][u];
        }
        return cnt[p];
    }
    
    bool startsWith(string prefix) {
        int p = 0, n = prefix.size();
        for (int i = 0; i < n; i ++)
        {
            int u = prefix[i] - 'a';
            if (!son[p][u]) return false;
            p = son[p][u];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

注释版代码：

```c++
class Trie {
public:
    // 定义最大节点数。
    // LeetCode 题目通常限制操作次数，假设所有单词总长不超过 10^5，
    // 设置 N = 100000 以上即可。您设为 300010 非常稳健。
    static const int N = 300010;

    // son[p][u] 存储树的结构
    // p: 当前节点的编号 (0 是根节点)
    // u: 当前字符的映射 (a->0, b->1 ... z->25)
    // 值: 子节点的编号
    int son[N][26]; 
    
    // cnt[p] 标记节点 p 是否是一个单词的结尾
    // 虽然名字叫 cnt (count)，但在本题逻辑中作为 bool (isEnd) 使用
    bool cnt[N]; 
    
    // idx: 全局节点计数器，用来给新节点分配唯一的编号
    // 0 号点既是根节点，也是空指针的概念
    int idx = 0; 

    Trie() {
        // 初始化。
        // 注意：这种双层循环初始化在 N 很大时可能会稍慢。
        // 既然是类成员变量，更推荐使用 memset(son, 0, sizeof son);
        // 或者在 insert 时动态处理，不过针对本题这种写法也没问题。
        for (int i = 0; i < N; i ++)
            for (int j = 0; j < 26; j ++)
                son[i][j] = 0;
                
        // 别忘了初始化 cnt 数组和 idx，防止多次实例化出错
        // memset(cnt, 0, sizeof cnt); 
        // idx = 0; // 如果 Trie 对象被重复使用，这里需要重置
    }
    
    void insert(string word) {
        int p = 0, n = word.size();
        for (int i = 0; i < n; i ++)
        {
            int u = word[i] - 'a'; // 将字符映射为 0-25
            
            // 如果当前节点 p 没有走向 u 的路，就新建一个节点
            if (son[p][u] == 0) son[p][u] = ++ idx;
            
            // 指针移动到下一个节点
            p = son[p][u];
        }
        // 循环结束，p 停留在单词的最后一个字符对应的节点上
        // 标记该节点为单词结尾
        cnt[p] = true; 
        return ;
    }
    
    bool search(string word) {
        int p = 0, n = word.size();
        for (int i = 0; i < n; i ++)
        {
            int u = word[i] - 'a';
            // 如果路断了（值为0），说明树里没这个前缀，肯定不存在该单词
            if (!son[p][u]) return false;
            p = son[p][u];
        }
        // 走完了所有字符，还要检查这里是不是一个单词的结尾
        // 比如树里有 "apple"，现在查 "app"，虽然路通了，但 "app" 不是存入的单词，返回 false
        return cnt[p];
    }
    
    bool startsWith(string prefix) {
        int p = 0, n = prefix.size();
        for (int i = 0; i < n; i ++)
        {
            int u = prefix[i] - 'a';
            // 只要路断了，就返回 false
            if (!son[p][u]) return false;
            p = son[p][u];
        }
        // 只要能走完，说明前缀存在。不需要检查 cnt[p]
        return true;
    }
};
```

