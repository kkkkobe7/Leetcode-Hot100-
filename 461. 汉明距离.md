# 461. 汉明距离

### 位运算

 解题思路拆解

**1. 理解“不同”：异或 (XOR)**
*   题目要求找“对应二进制位**不同**的位置数目”。
*   在位运算中，哪个符号专门负责处理“不同”？
    *   **异或 (`^`)**：
        *   `0 ^ 0 = 0` (相同)
        *   `1 ^ 1 = 0` (相同)
        *   `0 ^ 1 = 1` (不同 -> 结果为 1)
        *   `1 ^ 0 = 1` (不同 -> 结果为 1)
*   所以，第一步非常简单：直接计算 `s = x ^ y`。
*   结果 `s` 中，凡是二进制位是 `1` 的地方，就代表 `x` 和 `y` 在那个位置上不一样。

**2. 数“1”的个数 (Popcount)**
*   现在问题转化成了：**“给你一个整数 `s`，请问它的二进制表示里有多少个 `1`？”**
*   **方法 A (右移法 - 您的解法)：**
    *   看最低位是不是 1 (`s & 1`)？是就计数 +1。
    *   把数字往右移一位 (`s >>= 1`)，把刚才那个最低位扔掉。
    *   重复直到数字变成 0。
*   **方法 B (布赖恩·克尼根算法 - 进阶)：**
    *   `s & (s - 1)` 可以直接消除掉最低位的那个 `1`。
    *   这种方法跳得更快，有几个 1 就循环几次（比如 `100000` 只需要循环一次）。



简洁版代码：

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int s = x ^ y, ret = 0;
        while (s) {
            ret += s & 1;
            s >>= 1;
        }
        return ret;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        // 1. 异或运算
        // 异或的特性是：相同为 0，不同为 1
        // 计算后，s 的二进制位中为 1 的位置，就是 x 和 y 不同的位置
        int s = x ^ y;
        
        // ret 用于记录 1 的个数
        int ret = 0;
        
        // 2. 统计 1 的个数
        // 只要 s 还没变成 0，说明还有位是 1
        while (s) {
            // s & 1 取出最低位
            // 如果最低位是 1，ret 加 1；是 0，ret 加 0
            ret += s & 1;
            
            // 右移一位，抛弃已经统计过的最低位
            // 相当于 s = s / 2
            // 比如 101 (5) -> 10 (2) -> 1 (1) -> 0 (0)
            s >>= 1;
        }
        
        return ret;
    }
};
```

c++有内置函数

```c++
int hammingDistance(int x, int y){
    return __builtin_popcount(x ^ y);
}
```

