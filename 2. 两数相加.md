# 2. 两数相加

解题思路拆解

**1. 模拟竖式加法**
*   我们在做加法时，从低位开始。每一位的计算公式是：
    `总和 = 加数1 + 加数2 + 进位`
*   **当前位的结果**：`总和 % 10`（只留个位）。
*   **新的进位**：`总和 / 10`（给下一位用）。

**2. 核心挑战：长度不齐与进位**
*   **长度不齐**：两个链表长度可能不一样（比如 $123 + 45$）。当其中一个链表走完时，我们可以假设它的值是 `0`。
*   **最后一位进位**：这是最容易漏掉的点。比如 $99 + 1$，循环结束时进位 `t` 还是 `1`，我们需要额外创建一个节点来存放这个最后的 `1`。

**3. 技巧：哨兵节点 (Dummy Node)**
*   和合并链表一样，我们创建一个“假头” `ans`。
*   我们用一个 `cur` 指针来负责往 `ans` 后面接新的计算结果。
*   最后返回 `ans->next`。

简洁版代码：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *p = l1, *q = l2, *ans = new ListNode(), *cur = ans;
        int t = 0;
        while (l1 || l2)
        {

            int sum = (l1 == nullptr?0: l1->val) + (l2 == nullptr?0: l2->val) + t;
            cur->next = new ListNode(sum % 10);
            t = sum / 10;

            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
            cur = cur->next;
        }
        if (t) cur->next = new ListNode(t);
        return ans->next;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 1. 初始化
        // ans 是哨兵节点（Dummy Node），用于简化头节点的操作
        // cur 是移动指针，用来构建新链表
        // t 代表进位 (Carry)
        ListNode *ans = new ListNode(), *cur = ans;
        int t = 0;

        // 2. 只要还有数字没加完（l1没完 或 l2没完），就继续循环
        while (l1 || l2)
        {
            // 如果某个链表已经空了，我们就取 0 作为它的值
            int v1 = (l1 == nullptr ? 0 : l1->val);
            int v2 = (l2 == nullptr ? 0 : l2->val);

            // 3. 计算当前位的总和：两个加数 + 上一位留下的进位
            int sum = v1 + v2 + t;

            // 4. 更新当前位的结果和新的进位
            // sum % 10 是当前位留下的数字
            cur->next = new ListNode(sum % 10);
            // sum / 10 是要传给下一位的进位（要么是 0，要么是 1）
            t = sum / 10;

            // 5. 移动指针，准备计算下一位
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
            cur = cur->next;
        }

        // 6. 【关键点】循环结束后的最后一次进位
        // 比如 99 + 1，循环结束后进位 t 是 1，需要再补一个节点
        if (t) cur->next = new ListNode(t);

        // 7. 返回哨兵节点的下一个，即真正的结果链表头
        return ans->next;
    }
};
```

