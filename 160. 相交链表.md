# 160. 相交链表

参考[Krahets](https://leetcode.cn/u/jyd/)

假设链表`headA`有a个元素，`headB`有b的元素，公共部分有$c$个元素，那么`headA`在公共节点之前有$a-c$个元素，`headB`在公共节点前有$b-c$个元素。

用两个指针`A,B`分别指向`headA,headB`，分别遍历到对应链表尾部后切换到另一个链表重新开始遍历。

对于`A`指针，在切换链表后走到公共节点需要 $a + (b-c)$步

对于`B`指针，在切换链表后走到公共节点需要 $b + (a-c)$步

此时，两个指针重合

如果两个链表有公共节点，$c > 0$，那此时指向同一个节点

如果没有公共节点，$c = 0$，那么此时同时指向`nullptr`

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B)
        {
            A = (A != nullptr)? A->next: headB;
            B = (B != nullptr)? B->next: headA;
        }
        return A;
    }
};
```

