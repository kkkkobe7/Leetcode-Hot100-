# 236. 二叉树的最近公共祖先

二叉树类似问题优先思考递归。

函数`TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)`的含义是对以`root`为根的树，查找节点`p`和`q`，返回`p`和`q`的最近公共祖先。

如果要满足能在当前树下找到最近公共祖先，那么一定满足`p`或`q`位于当前树下。

情况可以划分为三种：

1. `p == root || q == root`，或者当前`root == nullptr`，直接返回`root`。
2. `p`和`q`在左右两侧，则可以在两侧分别找到。即`lowestCommonAncestor(root->left, p, q)`和`lowestCommonAncestor(root->right, p, q)`均有返回值。
3. `p`或`q`在单侧。位于`root->left`下，则返回`lowestCommonAncestor(root->left, p, q)`。反之，返回`lowestCommonAncestor(root->right, p, q)`。

所以，最终代码为

```c++
class Solution {
public:
    // 以root为根，找到p、q的最近公共祖先
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 判断p或者q是否在当前root为根的树上
        if (root == p || root == q || root == nullptr) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        // 如果p、q分布在左右子树，则当前root为LCA
        if (left && right) return root;

        // 否则在单侧
        return left? left: right;
    }
};
```

