# 647. 回文子串

本解答用的是动态规划的思路（官方解答有中心扩展法的思路）

### 解题思路拆解

**1. 核心定义 (DP State)**

- 我们定义`` f[i][j]`` 为布尔值：表示字符串 s 从索引 i 到 j 的子串（即 `s[i...j]`）**是否是回文串**。

**2. 状态转移 (Transition)**

- 如果要判断 `s[i...j]` 是不是回文，我们需要看两点：**两头必须相等：** `s[i]` 必须等于 `s[j]`。如果开头和结尾都不一样，那肯定不是回文。**中间部分必须是回文：** 去掉头尾后，剩下的 `s[i+1 ... j-1]` 必须也是回文（即依赖于 `f[i+1][j-1]`）。

**3. 特殊情况（Base Case）**

- **单个字符：** `s[i...i] `肯定是回文。（代码中 ans 初始化为 n 隐含处理了，或者` f[i][i]=true`）。
- **相邻字符：** 如果 `j = i + 1`，中间是空的，只要 `s[i] == s[j] `就是回文，不需要查 DP 表。

**4. 遍历顺序（难点）**

- 看公式：`f[i][j]` 依赖于` f[i+1][j-1]`。
- 要想求 i，必须先知道 i+1（更下面的行）。
- 要想求 j，必须先知道 j-1（更左边的列）。
- **结论：** i 必须**倒着遍历**（从 n-1 到 0），这样计算 i 的时候 i+1 已经算好了。j 则顺着从 i+1 往后遍历即可。

简洁版代码：

```c++
class Solution {
public:
    static const int N = 1010;
    bool f[N][N]; // 代表s[i, j]是否为回文子串（注意此处 j > i）
    // f[i][j]为回文子串 那么一定有f[i+1][j-1]为回文子串 且 s[i] == s[j] 
    // 从递推公式可以看出i需要从大到小遍历，j从小到大
    // 此外，如果j = i + 1，且s[i] == s[j]，即相邻两个相等，也满足

    int countSubstrings(string s) {
        int n = s.size();
        int ans = n;
        for (int i = n - 1; i >= 0; i --)
        {
            f[i][i] = true;
            for (int j = i + 1; j < n; j ++)
            {
                if (s[i] == s[j] && (f[i+1][j-1] || j == i + 1))
                {
                    f[i][j] = true;
                    ans ++;
                }
            }
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 设置为 1010，满足题目 s.length <= 1000
    static const int N = 1010;
    
    // DP 表
    // f[i][j] == true 表示 s[i...j] 是回文串
    // 注意：如果是多次调用（LeetCode环境），C++类成员数组记得初始化，或者在函数内使用 vector
    bool f[N][N]; 

    int countSubstrings(string s) {
        int n = s.size();
        
        // 初始化 ans = n
        // 因为每个单独的字符 s[i] 本身肯定是一个回文串
        // 所以我们先加上这 n 个，后面循环只统计长度 >= 2 的回文串
        // (当然，也可以 ans=0，然后在循环里把 f[i][i] 的情况也加上，您的写法更简练)
        int ans = n;

        // 1. 外层循环：倒序遍历 i (左边界)
        // 为什么倒序？因为计算 f[i][j] 需要用到 f[i+1][...]
        // 我们必须先把 i 大的行算出来，才能算 i 小的行
        for (int i = n - 1; i >= 0; i --)
        {
            // 单个字符肯定是回文
            f[i][i] = true; 
            
            // 2. 内层循环：正序遍历 j (右边界)
            // j 从 i+1 开始，只考虑长度至少为 2 的子串
            for (int j = i + 1; j < n; j ++)
            {
                // 核心判断逻辑
                // 条件 1: s[i] == s[j] (首尾字符必须相同)
                // 条件 2: 
                //    情况 A: j == i + 1 (相邻字符，如 "aa")，中间为空，无需查表，直接是回文
                //    情况 B: f[i+1][j-1] 为 true (中间部分 s[i+1...j-1] 是回文)
                if (s[i] == s[j] && (j == i + 1 || f[i+1][j-1]))
                {
                    f[i][j] = true; // 标记当前子串为回文
                    ans ++;         // 计数器 +1
                }
            }
        }
        return ans;
    }
};
```

