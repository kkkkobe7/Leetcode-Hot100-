# 121. 买卖股票的最佳时机

解题思路拆解

**1. 核心矛盾：低买高卖**
*   我们想要 $Profit = Price[sell] - Price[buy]$ 最大，且必须满足 $sell > buy$。
*   **直觉思维：** 如果我在第 $i$ 天打算卖出股票，我能拿到的最大利润是多少？
*   **结论：** 利润的大小取决于第 $i$ 天的价格，减去 **第 $i$ 天之前出现的最低价格**。

**2. 贪心算法的逻辑**
*   我们不需要知道所有天的价格，只需要在遍历的过程中记住两个变量：
    1.  `low`: 到今天为止，历史上出现过的**最低价格**（买入点）。
    2.  `ans`: 到今天为止，我们能获得的**最大利润**。
*   **遍历每一天：**
    *   如果今天卖掉比之前的最大利润还高，更新 `ans`。
    *   如果今天的价格比历史最低还低，更新 `low`。

**3. 动态规划的逻辑**
*   **状态定义：** `dp[i]` 表示前 $i$ 天所能获得的最大利润。
*   **状态转移：** 
    *   第 $i$ 天的最大利润，要么是**前 $i-1$ 天就已经达到的最大利润**；
    *   要么是**今天卖出的利润**（当前价格 - 历史最低价）。
*   公式：`dp[i] = max(dp[i-1], prices[i] - min_price)`。
*   **空间优化：** 你会发现 `dp[i]` 只依赖于 `dp[i-1]`，所以其实没必要开数组，用一个变量存 `ans` 即可，这就是为什么 DP 写到最后就变成了贪心。



贪心法：

```c++
class Solution {
public:
    // 单次买卖
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int ans = 0, low = prices[0];
        for (int i = 1; i < n; i ++)
        {
            if (prices[i] - low > ans) ans = prices[i] - low;
            else if (prices[i] < low) low = prices[i];
        }
        return ans;
    }
};
```

动态规划：

```
class Solution {
public:
    static const int N = 1e5 + 10;
    int dp[N];

    // 单次买卖
    int maxProfit(vector<int>& prices) {
        int n = prices.size(), low = prices[0];
        dp[0] = 0;
        for (int i = 1; i < n; i++)
        {
            dp[i] = max(dp[i-1], prices[i] - low); // 可以不用数组，等价于上面的贪心
            low = min(low, prices[i]);
        }
        return dp[n-1];
    }
};
```

