# 215. 数组中的第k个最大元素

参考快速排序思路，每次划分出左右部分，快排模板（参考yxc）如下

```c++
int q[N];

void quick_sort(int q[], int l, int r) // [l, r]，左闭右闭，从小到大排序
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```

**注意**，快排有两种模板，在这个模板中，并没有在每一次递归的时候对pivot进行归位，只是保证$q[l, j]<=x，q[j+1, r]>=x (以j为准，注意等号)$，但无法确定x在左侧还是右侧。在触发递归结束条件`l >= r`的时候，对应`q[l]`一定在对应位置（但是这个很好记，写起来很快）。



解题思路拆解 (从快排到快速选择)

**1. 核心差异**
*   **全排序 (Quick Sort)：** 我要把全校学生按身高排好队，然后告诉你第 10 名是谁。 (做了多余的功，我们不需要知道第 11 名到最后一名是谁)。
*   **快速选择 (Quick Select)：** 也是每次把人分成“高个子组”和“矮个子组”。
    *   如果“高个子组”有 15 个人，那第 10 名肯定在里面。**矮个子组我就完全不用管了**（不用递归处理那一半）。
    *   这就是将 $O(N \log N)$ 降为 $O(N)$ 的秘诀：**每次只递归一半**。

**2. 算法流程**
*   **选基准 (Pivot)：** 随便选个数 `x`。
*   **分治 (Partition)：** 把小于 `x` 的放左边，大于 `x` 的放右边。
*   **计数 (Count)：** 假设左边那一堆有 `S_L` 个元素。
    *   如果我们要找的是第 `k` 小的数：
    *   **情况 A：** `k <= S_L`。说明目标在左边。递归左边，找第 `k` 个。
    *   **情况 B：** `k > S_L`。说明目标在右边。递归右边，找第 `k - S_L` 个（减去左边已经淘汰的数量）。

**3. 关于第 K 个“最大”**
*   模板是从小到大排序。
*   **第 K 个最大** = **第 N - K + 1 个最小**。
*   我们在调用函数时，传入转换后的序号即可直接套用从小到大的模板。



Leetcode代码如下

```c++
class Solution {
public:
    int quick_sort(vector<int>& q, int l, int r, int k)
    {
        if (l >= r) return q[l];

        int i = l - 1, j = r + 1, x = q[i + j >> 1];
        while (i < j)
        {
            do i ++; while (q[i] < x);
            do j --; while (q[j] > x);
            if (i < j) swap(q[i], q[j]);
        } 
		
        /* 
        1. 第k大的元素在有序数组的下标为[q.size() - k]（例如 第一大的元素应该是q[q.size() - 1])。
           换句话说，该元素左侧有q.size()-k个元素满足 <=q[k]
        2. q[l, j]<=x，q[j+1, r]>=x，等价于 q[l, j] <= x <= q[j+1, r]
           那么，j + 1左侧一定有j + 1个元素满足 <=q[j+1]
        3. 如果q.size() - k >= j + 1，那么该元素一定在j+1右侧（包括j+1）
           如果q.size() - k < j + 1，代表第k大的元素在j+1左侧
           由于这个模板只有在l >= r的时候，q[l]才在对应有序位置，所以仅在 l >= r 的时候 return q[l];
        */
        if (q.size() - k >= j + 1) return quick_sort(q, j + 1, r, k);
        else return quick_sort(q, l, j, k);
    }
    int findKthLargest(vector<int>& nums, int k) {
        return quick_sort(nums, 0, nums.size() - 1, k);
    }
};
```

注释版：

```c++
class Solution {
public:
    // 寻找区间 [l, r] 中第 k 小的数 (注意是第 k 小，不是下标)
    int quick_select(vector<int>& q, int l, int r, int k) {
        // 1. 终止条件：区间只剩下一个数，那就是答案
        if (l >= r) return q[l];

        // 2. 选取基准 & 双指针初始化
        int i = l - 1, j = r + 1, x = q[l + r >> 1];
        
        // 3. 划分区间 (Partition)
        // 使得 q[l..j] <= x, q[j+1..r] >= x
        while (i < j) {
            do i++; while (q[i] < x);
            do j--; while (q[j] > x);
            if (i < j) swap(q[i], q[j]);
        }

        // 4. 核心逻辑：只递归一边
        // 计算左半边区间 [l, j] 的长度
        int sl = j - l + 1; 
        
        // 如果 k 在左半边的范围内
        if (k <= sl) {
            return quick_select(q, l, j, k);
        } else {
            // 否则，目标在右半边
            // 注意：我们要找右半边的第 (k - sl) 个数
            return quick_select(q, j + 1, r, k - sl);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        // 题目求第 k 个“最大”，等价于求从小到大排序后的第 n - k + 1 个“最小”
        // 比如 [1,2,3,4,5], k=2 (第2大是4), 也就是第 5-2+1 = 4 小
        return quick_select(nums, 0, nums.size() - 1, nums.size() - k + 1);
    }
};
```

