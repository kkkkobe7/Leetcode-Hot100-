# 215. 数组中的第k个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```c++
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```c++
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

- `1 <= k <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`



参考快速排序思路，每次划分出左右部分，快排模板（参考yxc）如下

```c++
int q[N];

void quick_sort(int q[], int l, int r) // [l, r]，左闭右闭，从小到大排序
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```

**注意**，快排有两种模板，在这个模板中，并没有在每一次递归的时候对pivot进行归位，只是保证$q[l, j]<=x，q[j+1, r]>=x (以j为准，注意等号)$，但无法确定x在左侧还是右侧。在触发递归结束条件`l >= r`的时候，对应`q[l]`一定在对应位置（但是这个很好记，写起来很快）。

对于这道题，由于需要找到第k大的，那么需要在快排函数中加入参数`k`

Leetcode代码如下

```c++
class Solution {
public:
    int quick_sort(vector<int>& q, int l, int r, int k)
    {
        if (l >= r) return q[l];

        int i = l - 1, j = r + 1, x = q[i + j >> 1];
        while (i < j)
        {
            do i ++; while (q[i] < x);
            do j --; while (q[j] > x);
            if (i < j) swap(q[i], q[j]);
        } 
		
        /* 
        1. 第k大的元素在有序数组的下标为[q.size() - k]（例如 第一大的元素应该是q[q.size() - 1])。
           换句话说，该元素左侧有q.size()-k个元素满足 <=q[k]
        2. q[l, j]<=x，q[j+1, r]>=x，等价于 q[l, j] <= x <= q[j+1, r]
           那么，j + 1左侧一定有j + 1个元素满足 <=q[j+1]
        3. 如果q.size() - k >= j + 1，那么该元素一定在j+1右侧（包括j+1）
           如果q.size() - k < j + 1，代表第k大的元素在j+1左侧
           由于这个模板只有在l >= r的时候，q[l]才在对应有序位置，所以仅在 l >= r 的时候 return q[l];
        */
        if (q.size() - k >= j + 1) return quick_sort(q, j + 1, r, k);
        else return quick_sort(q, l, j, k);
    }
    int findKthLargest(vector<int>& nums, int k) {
        return quick_sort(nums, 0, nums.size() - 1, k);
    }
};
```



