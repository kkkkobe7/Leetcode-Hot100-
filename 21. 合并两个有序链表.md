# 21. 合并两个有序链表

解题思路拆解

**1. 形象理解：拉链合拢**
*   想象你有两条拉链（两个链表），每一边都是按从小到大排好的。
*   你需要把它们合成一条。你手里拿着两个指针（`p` 和 `q`），分别指向两条拉链的开头。
*   **动作**：哪边的齿（节点值）小，你就把哪边的齿接在新的拉链后面，然后让那一边的指针往后移一位。
*   **结束**：直到其中一条拉链用完了，就把另一条剩下的部分直接整段接上去。

**2. 核心技术：哨兵节点 (Dummy Node)**
*   在合并链表时，最麻烦的是确定“谁是第一个节点”。
*   **技巧**：我们先创建一个假的头节点（哨兵节点）。这样我们就不用写一堆 `if` 来判断新链表的头是谁了。所有的节点都一视同仁地接到这个“假头”后面，最后返回 `假头->next` 即可。

简洁版代码：

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (list1 == nullptr) return list2;
        if (list2 == nullptr) return list1;
        ListNode *ans = new ListNode(), *p = list1, *q = list2;
        while(p && q)
        {
            if (p->val <= q->val) 
            {
                ans->next = p;
                p = p->next;
            }
            else
            {
                ans->next = q;
                q = q->next;
            }
            ans = ans->next;
        }
        if (p) ans->next = p;
        if (q) ans->next = q;
        return list1->val <= list2->val? list1: list2;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 1. 特判：如果其中一个链表为空，直接返回另一个
        if (list1 == nullptr) return list2;
        if (list2 == nullptr) return list1;

        // 2. 初始化
        // ans 其实充当了哨兵节点（Dummy Node）的角色
        // p 和 q 分别是遍历两个原链表的“侦察兵”
        ListNode *dummy = new ListNode(); 
        ListNode *ans = dummy; // ans 在这里实际上是新链表的“尾指针”，负责往后接人
        ListNode *p = list1, *q = list2;

        // 3. 循环比较
        // 只要两个链表都没走到头，就继续比大小
        while(p && q)
        {
            if (p->val <= q->val) 
            {
                ans->next = p; // p 比较小，把 p 接在新链表后面
                p = p->next;   // p 往后走一步
            }
            else
            {
                ans->next = q; // q 比较小，把 q 接上
                q = q->next;   // q 往后走一步
            }
            ans = ans->next;   // 新链表的尾巴也要往后移动一位
        }

        // 4. 收尾工作
        // 如果其中一个链表先走完了，把剩下的那一个（本身就是有序的）直接挂在后面
        if (p) ans->next = p;
        if (q) ans->next = q;

        // 5. 返回结果
        // 按照你的逻辑：头节点必然是 list1 和 list2 中较小的那个
        return list1->val <= list2->val ? list1 : list2;
        
        // 更有通用性的做法是：
        // return dummy->next;
    }
};
```

