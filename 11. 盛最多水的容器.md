# 11. **盛最多水的容器**

解题思路拆解

**1. 面积公式**
$$\text{Area} = \min(\text{height}[l], \text{height}[r]) \times (r - l)$$

**2. 初始状态：最大宽度**
*   我们设置两个指针 `l` (左) 和 `r` (右)，分别指向数组的最两端。此时，**底边的宽度是最大的**。

**3. 核心决策：该移动哪一根柱子？**
*   **贪心策略**：每次移动**较短**的那根柱子。
*   **为什么要移动短的？**
    *   容器的高度受限于**短板**。
    *   如果你移动长板，底边宽度肯定会减小，而容器的高度依然被那根短板限制，或者变得更短。所以面积**只会减小，不会增大**。
    *   只有移动短板，我们才有可能遇到一根更长的柱子，从而弥补底边宽度减小带来的损失，甚至获得更大的面积。

**4. 优化：跳过无意义的柱子**
*   当你移动短板后，如果新遇到的柱子比刚才的那根还短，那么面积肯定更小。我们可以直接跳过这些柱子，直到找到一根比刚才更高的柱子。



简洁版代码：

```c++
class Solution {
public:
    // 存储水的容器，容量取决于左右两个柱子中较低柱子的高度以及两个柱子的距离 area = min(h[l],h2=h[r])*(r-l)
    int maxArea(vector<int>& height) {
        int n = height.size();
        int l = 0, r = n - 1, ans = 0;
        while (l < r)
        {
            ans = max(ans, min(height[l], height[r])*(r-l));
            if (height[l] <= height[r])
            {
                // 找到下一个更高的l
                int l1 = l + 1;
                for (int i = 0; i + l1 < r; i ++)
                {
                    if (height[l1 + i] > height[l])
                    {
                        l = l1;
                        break;
                    }
                }
                if (l != l1) break;
            }
            else
            {
                int r1 = r - 1;
                for (int i = 0; r1 - i > l; i ++)
                {
                    if (height[r1-i] > height[r])
                    {
                        r = r1;
                        break;
                    }
                }
                if (r != r1) break;
            }
        }
        return ans;
    }
};
```



注释版代码：

```c++
class Solution {
public:
    // 核心思想：双指针向中间收缩，每次放弃掉当前的“短板”
    int maxArea(vector<int>& height) {
        int n = height.size();
        int l = 0, r = n - 1, ans = 0;
        
        while (l < r)
        {
            // 1. 计算当前面积并更新全局最大值
            // 面积 = 左右两边较矮的高度 * 左右两边的距离
            int current_height = min(height[l], height[r]);
            ans = max(ans, current_height * (r - l));
            
            // 2. 贪心决策：哪边矮，哪边就往中间移
            if (height[l] <= height[r])
            {
                // 左侧柱子是短板，我们尝试在左侧找一个更高的
                int old_l = l;
                l++; 
                // 优化：跳过所有比刚才那根柱子还矮或一样高的柱子
                while (l < r && height[l] <= height[old_l]) {
                    l++;
                }
            }
            else
            {
                // 右侧柱子是短板，我们尝试在右侧找一个更高的
                int old_r = r;
                r--;
                // 优化：跳过所有比刚才右侧还矮的柱子
                while (r > l && height[r] <= height[old_r]) {
                    r--;
                }
            }
        }
        return ans;
    }
};
```

