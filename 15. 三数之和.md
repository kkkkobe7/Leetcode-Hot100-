# 15. 三数之和

解题思路拆解

**1. 排序是前提**
*   **为什么要排序？**
    1.  排序后，我们可以使用**双指针**从两端向中间移动。
    2.  排序让相同的数字相邻，方便我们**跳过重复数字**，从而实现去重。
    3.  如果当前数字已经大于 0，那么它右边的数字肯定也大于 0，三数之和绝不可能为 0，可以直接结束。

**2. 核心模型：固定一个，双指针找另外两个**
我们将问题转化为：对于数组中的每一个位置 `i`，寻找在其右侧范围内是否存在两个数 `j` 和 `k`，使得 $nums[j] + nums[k] = -nums[i]$。
*   **指针 `i`**：固定最左侧的最小数。
*   **指针 `j`**：左指针，初始为 `i + 1`。
*   **指针 `k`**：右指针，初始为 `n - 1`。

**3. 指针移动逻辑**
*   计算 `sum = nums[i] + nums[j] + nums[k]`。
*   如果 `sum == 0`：找到一组解，记录。然后 **`j` 右移，`k` 左移**，并跳过所有重复的值。
*   如果 `sum > 0`：说明数值太大了，需要减小，于是 **`k` 左移**。
*   如果 `sum < 0`：说明数值太小了，需要增大，于是 **`j` 右移**。

**4. 去重的艺术（面试关键）**
为了不重复，我们在 `i`、`j`、`k` 移动时，都要判断：如果下一个数和当前的数一样，就直接跳过。

简洁版代码：

```c++
class Solution {
public:
    // 三数之和为0，一定有正有负
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        int n = nums.size();
        int i = 0; // 固定最左侧的数
        while (i < n - 2)
        {
            if (nums[i] > 0) break;
            int j = i + 1, k = n - 1;
            while (j < k && j < n - 1)
            {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0)
                {
                    ans.push_back({nums[i], nums[j], nums[k]});
                    do j ++; while (j < n - 2 && nums[j] == nums[j - 1]);
                    do k --; while (k > j + 1 && nums[k] == nums[k + 1]);
                }
                else if (sum > 0) do k --; while (k > j + 1 && nums[k] == nums[k + 1]);
                else do j ++; while (j < n - 2 && nums[j] == nums[j - 1]);
            }
            do i ++; while (i < n - 2 && nums[i] == nums[i-1]);
        }

        return ans;
    }
};
```

注释版代码：

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 1. 预处理：排序。这是使用双指针的前提。
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        int n = nums.size();
        
        int i = 0; // i 是我们固定的第一个数
        while (i < n - 2)
        {
            // 剪枝优化：如果当前最小的数已经大于 0，后面都是正数，和不可能为 0
            if (nums[i] > 0) break;

            int j = i + 1, k = n - 1; // j 是左指针，k 是右指针

            // 2. 双指针内部循环
            while (j < k)
            {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0)
                {
                    ans.push_back({nums[i], nums[j], nums[k]});
                    
                    // 找到答案后，跳过所有重复的 j 和 k 
                    // 这样可以确保不收集重复的三元组
                    do { j++; } while (j < k && nums[j] == nums[j - 1]);
                    do { k--; } while (j < k && nums[k] == nums[k + 1]);
                }
                else if (sum > 0) 
                {
                    // 和太大，右指针左移
                    do { k--; } while (j < k && nums[k] == nums[k + 1]);
                }
                else 
                {
                    // 和太小，左指针右移
                    do { j++; } while (j < k && nums[j] == nums[j - 1]);
                }
            }

            // 3. 固定位 i 也要去重
            // 如果下一个 i 的值和当前一样，跳过，否则会得到重复的组合
            do { i++; } while (i < n - 2 && nums[i] == nums[i - 1]);
        }

        return ans;
    }
};
```

