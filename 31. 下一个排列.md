# 31. 下一个排列

参考[Imageslr题解](https://leetcode.cn/u/imageslr/)

解题思路拆解

**1. 核心目标：变大，但大的尽可能小**
要让一个排列变大，我们必须把一个“较小的数”和它后面一个“较大的数”交换。
*   **如何变大？** 把低位的数字提到高位。
*   **如何大的尽可能小？** 
    *   交换的位置要尽可能**靠右**。
    *   交换后的“新高位”要尽可能小。
    *   交换后的“低位”要按**升序**排列（因为升序是当前数字组合能形成的最小值）。

**2. 具体步骤（三步走策略）**
1.  **从后往前找“拐点”**：
    寻找第一个相邻的升序对 `(i-1, i)`，使得 `nums[i-1] < nums[i]`。此时 `nums[i-1]` 就是我们要替换的**小数**（small）。因为它后面出现了更大的数，说明它可以变大。
2.  **寻找“接班人”**：
    在 `small` 右侧的所有数字中，找到比 `nums[small]` 大的数字里最小的那一个。
    *   *技巧*：由于 `small` 右侧现在是降序排列的，我们只需从后往前找，第一个大于 `nums[small]` 的数就是我们要找的 **大数**（big）。
3.  **交换与重排**：
    *   交换 `nums[small]` 和 `nums[big]`。
    *   此时，`small` 之后的部分依然是降序的。为了让排列最小，我们要把这一部分反转（变为升序）。

**3. 特殊情况**
*   如果从后往前找，发现整个数组是降序的（如 `3,2,1`），说明这已经是最大的排列。按照题目要求，直接反转整个数组变成 `1,2,3`。

简洁版代码：

```c++
class Solution {
public:
    /*
    123 132 213 231 312 321
    不考虑最后一个排列的话，下一个排列一定更大，但大的要尽可能小
    1. 更大：将后面的大数和前面小数交换
    2. 大的尽可能小：
        （1）尽可能在右侧交换，从后往前搜
        （2）找到小数位置后，选在其后面最小的大数，
        （3）交换后，大数后面的所有数升序
    */
    void nextPermutation(vector<int>& nums) {
        int n = nums.size(), small = -1, big = -1;
        for (int i = n - 1; i > 0; i --) // 从后向前找第一个相邻升序对确定小数位置
        {
            if (nums[i-1] < nums[i])
            {
                small = i - 1;
                break;
            }
        }  
        if (small == -1) // 已经是最大
        {
            reverse(nums.begin(), nums.end());
            return ;
        }
        for (int i = n - 1; i > small; i --) // 在小数后面，从后向前找，找到第一个更大的数就是大数（因为其他的是降序排列）
        {
            if (nums[i] > nums[small])
            {
                big = i;
                break;
            }
        }
        swap(nums[small], nums[big]); // 交换大小数
        reverse(nums.begin()+small+1, nums.end()); // 后面为降序，调整为升序，保证最小
        return ;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        int small = -1, big = -1;

        // 1. 从后往前寻找第一个相邻的升序对
        // 目的：找到最靠右的、可以变大的数字位置
        for (int i = n - 1; i > 0; i --) 
        {
            if (nums[i-1] < nums[i])
            {
                small = i - 1; // 找到了小数位置
                break;
            }
        }  

        // 如果没找到，说明整个数组是降序的，已经是字典序最大
        if (small == -1) 
        {
            // 直接反转成升序（最小排列）并返回
            reverse(nums.begin(), nums.end());
            return ;
        }

        // 2. 在小数 small 的右侧寻找“最小的大数”
        // 因为 small 右侧的数组目前是【降序】排列的
        // 所以从后往前找，第一个大于 nums[small] 的数就是目标
        for (int i = n - 1; i > small; i --) 
        {
            if (nums[i] > nums[small])
            {
                big = i; // 找到了接班人
                break;
            }
        }

        // 3. 交换小数和大数
        swap(nums[small], nums[big]); 

        // 4. 关键：反转小数位置后面的所有数字
        // 交换后，small 后面的序列依然是降序的。
        // 为了让“下一个排列”尽可能小，我们要把这部分降序序列反转成升序序列
        reverse(nums.begin() + small + 1, nums.end()); 
        
        return ;
    }
};
```

