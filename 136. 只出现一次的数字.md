# 136. 只出现一次的数字

**寻找突破口**

- 题目有两个关键信息：除了一个数字，其他数字都出现了**两次**。要求空间复杂度 `O(1)O(1)`（不能用哈希表记录次数）。

**2. 核心直觉：异或运算 (XOR) 的魔法**

- 异或运算（符号 ^）有三个对于这道题至关重要的性质：**归零律：** 任何数和自己异或，结果是 0 (a ^ a = 0)。 -> *这就像“消消乐”，一样的两个数碰到一起就抵消了。**恒等律：** 任何数和 0 异或，结果还是它自己 (a ^ 0 = a)。**交换律/结合律：** 异或运算不在乎顺序 (a ^ b ^ c = a ^ c ^ b)。

**3. 算法推导**

- 数组里有一堆数字，比如 [4, 1, 2, 1, 2]。
- 如果我们把它们全部异或起来：
    4 ^ 1 ^ 2 ^ 1 ^ 2
- 利用**交换律**，我们可以脑补把相同的放在一起：
    4 ^ (1 ^ 1) ^ (2 ^ 2)
- 利用**归零律**，成对的数字变成了 0：
    4 ^ 0 ^ 0
- 利用**恒等律**，结果就是那个剩下的数：
    4

简洁版代码：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int x = 0;
        for (int num : nums)  // 异或
            x ^= num;
        return x;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        // x 用于存储累积异或的结果
        // 初始化为 0，因为 0 ^ n = n，不会影响计算结果
        int x = 0;
        
        // 遍历数组中的每一个数字
        for (int num : nums)
        {
            // 执行异或运算
            // 利用性质：num ^ num = 0
            // 所有出现两次的数字都会在遍历过程中互相抵消变成 0
            // 只有那个出现一次的数字会留下来
            x ^= num;
        }
        
        // 最终 x 中保留的就是那个唯一的数字
        return x;
    }
};
```

