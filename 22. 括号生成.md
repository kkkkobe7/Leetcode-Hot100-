# 22. 括号生成

解题思路拆解

**1. 括号有效的核心条件**
在从左往右生成括号的过程中，要保证最终有效，必须满足以下两个动态条件：
1.  **左括号的数量不能超过 $n$**。
2.  **右括号的数量不能超过左括号的数量**。（如果右括号比左括号多，比如 `())`，那么这一串无论后面加什么，都不可能再合法了）。

**2. 递归状态定义**
我们使用 DFS 搜索，记录四个关键变量：
*   `l`: 当前已经使用的**左括号**数量。
*   `r`: 当前已经使用的**右括号**数量。
*   `n`: 目标总对数。
*   `s`: 当前正在构建的字符串。

**3. 递归的规则（剪枝逻辑）**
*   **尝试添加左括号**：只要 `l < n`（还有左括号额度），就可以添加 `(`。
*   **尝试添加右括号**：只要 `r < l`（当前有未配对的左括号），就可以添加 `)`。
*   **终止条件**：当 `l == n` 且 `r == n` 时，说明 $n$ 对括号已经全部合法放置，记录结果。

**4. 为什么这是高效的？**
通过 `r < l` 这个判断，我们直接排除了所有非法的路径（比如 `)(` 或者 `())`）。这大大缩小了搜索范围，这种在搜索过程中提前排除非法情况的技术就是“剪枝”。

简洁版代码：

```c++
class Solution {
public:
    vector<string> ans;

    void dfs(int l, int r, int n, string s)
    {
        if (l == r && l == n) 
        {
            ans.push_back(s);
            return ;
        }
        if (l < n) dfs(l + 1, r, n, s + "(");
        if (r < l) dfs(l, r + 1, n, s + ")");

        return ;
    }

    vector<string> generateParenthesis(int n) {
        dfs(0, 0, n, "");
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // 存储最终所有合法的组合
    vector<string> ans;

    // DFS 搜索函数
    // l: 已使用的左括号数, r: 已使用的右括号数
    // n: 限制对数, s: 当前构建中的字符串
    void dfs(int l, int r, int n, string s)
    {
        // 1. 终止条件
        // 当左括号和右括号都用完且相等时，说明找到了一个完整合法的组合
        if (l == r && l == n) 
        {
            ans.push_back(s);
            return;
        }

        // 2. 递归分支 A：尝试放左括号
        // 只要还没放够 n 个，就可以放左括号
        if (l < n) 
        {
            dfs(l + 1, r, n, s + "(");
        }

        // 3. 递归分支 B：尝试放右括号
        // 关键约束：只有当前右括号数量 < 左括号数量时，才能放右括号
        // 这保证了每一个 ')' 都有一个前面的 '(' 与之对应
        if (r < l) 
        {
            dfs(l, r + 1, n, s + ")");
        }

        // 注意：因为这里 s 是以值传递 (string s) 进来的，
        // 每一层都有自己的 s 拷贝，所以不需要显式回溯（pop_back）
    }

    vector<string> generateParenthesis(int n) {
        // 清空结果，从 0 个左括号 0 个右括号开始搜
        ans.clear();
        dfs(0, 0, n, "");
        return ans;
    }
};
```

