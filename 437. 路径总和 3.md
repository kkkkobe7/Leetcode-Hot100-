# 437. 路径总和 3

### 深搜

1.  **直观想法**：题目说“路径不需要从根节点开始”。那我们可以把树中的**每一个节点**都当成一次“根节点”来尝试。
2.  **拆解任务**：
    *   写一个辅函数 `dfs`：专门计算以**当前节点 `root` 为起点**，往下的路径中有多少条等于 `target`。
    *   写主函数 `pathSum`：遍历整棵树的每个节点。对于每个节点，都调用一次上面的 `dfs`。
3.  **复杂度分析**：
    *   如果树是平衡的，复杂度是 $O(N \log N)$。
    *   如果树退化成链表，每个节点都要往下搜到底，复杂度退化为 $O(N^2)$。这在面试中通常被认为是“可以接受但非最优”的解法。

简洁版代码：

```c++
class Solution {
public:
    int ans = 0;
    void dfs(TreeNode* root, long long int sum, int target)
    {
        if (root == nullptr) return ;

        sum += root->val;
        if (sum == target) ans ++;

        // 包括当前根节点的路径
        dfs(root->left, sum, target);
        dfs(root->right, sum, target);
    }

    int pathSum(TreeNode* root, int targetSum) {
        dfs(root, 0, targetSum);
        if (root) 
        {
            pathSum(root->left, targetSum);
            pathSum(root->right, targetSum);
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    int ans = 0; // 全局变量记录总路径数

    // 辅函数：计算以当前 root 为【起点】，向下延伸的路径中，和为 target 的数量
    void dfs(TreeNode* root, long long int sum, int target)
    {
        if (root == nullptr) return;

        sum += root->val; // 更新当前路径和
        
        // 如果当前路径和等于目标值，记录一条有效路径
        // 注意：不要 return！因为后面可能还有节点（比如 0 或正负抵消）使得和再次等于 target
        if (sum == target) ans ++;

        // 继续向下延伸
        dfs(root->left, sum, target);
        dfs(root->right, sum, target);
    }

    // 主函数：相当于遍历整棵树
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return 0;
        
        // 1. 以当前 root 为起点，找路径
        dfs(root, 0, targetSum);
        
        // 2. 递归：去左子树里，把左孩子当作新的起点找路径
        if (root->left) pathSum(root->left, targetSum);
        
        // 3. 递归：去右子树里，把右孩子当作新的起点找路径
        if (root->right) pathSum(root->right, targetSum);
        
        return ans;
    }
};
```







### 前缀和+深搜

思考过程
1.  **痛点**：做法一中有大量的重复计算。比如计算 A->B->C 和 B->C，节点 C 被重复访问了多次。
2.  **类比**：这其实就是 **[LeetCode 560] 和为 K 的子数组** 的“树上版本”。
    *   我们在数组里找 `target`，用的是 `currSum - oldSum = target`。
    *   在树上也是一样！我们维护一条从根节点到当前节点的路径。
3.  **核心逻辑**：
    *   维护一个全局的 HashMap `presum`，记录**从根节点出发的各种前缀和出现的次数**。
    *   当我们到达某个节点，当前前缀和为 `curr`。我们想知道：**它的祖先节点中，有没有谁的前缀和是 `curr - target`？**
    *   如果有 $N$ 个这样的祖先，那就说明存在 $N$ 条路径以当前节点结尾且和为 `target`。
4.  **回溯 (关键点)**：
    *   因为是树形结构，我们访问完左子树后，要回退到父节点再去右子树。
    *   **左子树里的前缀和，不能算作右子树的“祖先路径”**。
    *   所以，在离开当前节点（递归返回）之前，必须把当前节点的前缀和从 HashMap 中**删掉（计数减一）**。

简洁版代码：

```c++
class Solution {
public:
    int ans = 0;
    
    unordered_map<long long, int> presum = {{0, 1}}; // 注意初始化
    void dfs(TreeNode* root, long long sum, int target)
    {
        if (root == nullptr) return ;

        sum += root->val;
        ans += presum.contains(sum - target)? presum[sum - target]: 0;

        presum[sum] ++;
        dfs(root->left, sum, target);
        dfs(root->right, sum, target);
        presum[sum] --;  // 回溯
    }

    int pathSum(TreeNode* root, int targetSum) {
        dfs(root, 0, targetSum);
        return ans;
    }
};
```

注释版：

```c++
class Solution {
public:
    int ans = 0;
    
    // key: 前缀和的值, value: 这个前缀和出现的次数
    // 使用 long long 防止整数溢出
    unordered_map<long long, int> presum; 

    void dfs(TreeNode* root, long long sum, int target)
    {
        if (root == nullptr) return;

        // 1. 更新当前从根节点下来的路径前缀和
        sum += root->val;

        // 2. 核心公式：currSum - oldSum = target  =>  oldSum = currSum - target
        // 我们查找 map 里有没有 oldSum，如果有，说明中间有一段路径和为 target
        // C++20 使用 contains，旧版本可以用 if(presum.count(...))
        if (presum.contains(sum - target)) {
            ans += presum[sum - target];
        }

        // 3. 将当前的前缀和加入 map，方便子节点查询
        presum[sum] ++;

        // 4. 继续递归左右子树
        dfs(root->left, sum, target);
        dfs(root->right, sum, target);

        // 5. 【回溯关键一步】
        // 离开当前节点前，要把自己的前缀和从 map 中移除
        // 因为对于兄弟节点来说，当前节点并不是它们的祖先，不能算作路径的一部分
        presum[sum] --;  
    }

    int pathSum(TreeNode* root, int targetSum) {
        // 初始化 map
        // {0, 1} 的含义是：前缀和为 0 的情况出现过 1 次（即空路径）
        // 如果 sum 刚好等于 target，那么 sum - target = 0，我们需要 map[0] = 1 才能统计到这条从根出发的路径
        presum = {{0, 1}}; 
        
        dfs(root, 0, targetSum);
        return ans;
    }
};
```

