# 198. 打家劫舍

解题思路拆解

**1. 核心矛盾**
*   面对第 `i` 间房子，我有两个选择：
    *   **偷**：那么我就拿到了这间房的钱 `nums[i]`，但是代价是第 `i-1` 间房一定不能偷。
    *   **不偷**：那么我虽然没拿到这间房的钱，但我解除了对第 `i-1` 间房的限制（它偷不偷都行，我只要取前一天收益最大的那种情况即可）。

**2. 定义状态 (DP Array)**
*   我们需要记录截止到第 `i` 间房时的最大收益。
*   为了处理相邻限制，我们需要细化状态。您的代码定义了 `f[i][2]`：
    *   `f[i][0]`: 到了第 `i` 间房，我决定**不偷**这一间，此时的最大总金额。
    *   `f[i][1]`: 到了第 `i` 间房，我决定**偷**这一间，此时的最大总金额。

**3. 状态转移方程 (Transition)**
*   **计算 `f[i][0]` (今晚休息)**：
    *   既然我不动警报，那昨晚（`i-1`）我可以偷，也可以不偷。
    *   为了钱最多，我当然选昨晚收益最高的那种情况。
    *   `f[i][0] = max(f[i-1][0], f[i-1][1])`
*   **计算 `f[i][1]` (今晚动手)**：
    *   既然我动手了，昨晚（`i-1`）绝对不能动手，必须是 `f[i-1][0]` 状态。
    *   `f[i][1] = f[i-1][0] + nums[i]`

**4. 初始与结果**
*   第 0 天偷：收益 `nums[0]`。
*   第 0 天不偷：收益 `0`。
*   最终结果：看最后一天（`n-1`），选“偷”和“不偷”里钱更多的一个。
*   

简洁版代码：

```c++
class Solution {
public:
    // 不能偷连续的
    static const int N = 110;
    int f[N][2]; // dp数组

    int rob(vector<int>& nums) {
        int n = nums.size();

        // 初始化
        f[0][1] = nums[0]; // 第一天偷
        for (int i = 1; i < n; i ++)
        {
            f[i][0] = max(f[i-1][0], f[i-1][1]); // 如果今天不偷，昨天偷不偷都行
            f[i][1] = f[i-1][0] + nums[i]; // 如果今天偷，昨天不能偷
        }

        return max(f[n-1][0], f[n-1][1]);
    }
};
```

注释版：

```c++
class Solution {
public:
    // N 定义得稍大一点，防止越界
    static const int N = 110;
    
    // f[i][j] 是 DP 状态数组
    // i 代表第几间房子 (0 到 n-1)
    // j 代表状态：0 表示不偷第 i 间，1 表示偷第 i 间
    int f[N][2]; 

    int rob(vector<int>& nums) {
        int n = nums.size();
        
        // 【重要】多组测试用例环境下的初始化
        // 虽然在局部覆盖逻辑下不初始化可能也没事，但良好的习惯是清空
        // memset(f, 0, sizeof f); 

        // 1. 初始化 Base Case (第 0 间房)
        f[0][0] = 0;       // 第 0 间不偷，收益为 0
        f[0][1] = nums[0]; // 第 0 间偷，收益为 nums[0]

        // 2. 状态转移 Loop
        for (int i = 1; i < n; i ++)
        {
            // 情况 A：第 i 间房我不偷
            // 那么前一间房(i-1)偷不偷都可以，我们取其中的最大值
            f[i][0] = max(f[i-1][0], f[i-1][1]); 
            
            // 情况 B：第 i 间房我要偷
            // 限制条件生效：前一间房(i-1)必须没偷 (状态 0)
            // 收益 = 前一间没偷的累积金额 + 当前房间的现金
            f[i][1] = f[i-1][0] + nums[i]; 
        }

        // 3. 返回结果
        // 最后一间房，要么偷要么不偷，取最大者
        return max(f[n-1][0], f[n-1][1]);
    }
};
```

空间优化版（滚动数组）：

```c++
int prevNo = 0;       // f[i-1][0]
int prevYes = nums[0];// f[i-1][1]
for (int i = 1; i < n; i++) {
    int currNo = max(prevNo, prevYes); // 今天不偷
    int currYes = prevNo + nums[i];    // 今天偷
    
    prevNo = currNo;
    prevYes = currYes;
}
return max(prevNo, prevYes);
```

