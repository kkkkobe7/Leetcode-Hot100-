# 169. 多数元素

参考[Karhets](https://leetcode.cn/u/jyd/)

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

### 解题思路拆解

**1. 核心直觉：极限一换一**

- 这道题最核心的条件是：多数元素的数量 **大于** `n/2`。
- 想象这是一个战场，不同的数字代表不同的阵营。
- 规则很简单：**“一换一”**。只要遇到两个**不同**的兵（数字），他们就同归于尽（抵消）。如果是**相同**的兵，他们就抱团（计数增加）。

**2. 为什么能成功？**

- 因为“众数”这一派的兵力超过了总兵力的一半。
- 哪怕众数派跟**所有其他杂牌军**加起来打消耗战，每一个众数士兵带走一个非众数士兵，**最后活在战场上的，一定还是众数**。

**3. 算法流程模拟**

- 我们维护两个变量：x (Candidate)：当前擂台上的霸主（候选人）。votes (Count)：当前霸主的血量（票数）。
- **遍历数组：**如果是空的（votes == 0）： 说明之前的兵都死光了，当前这个数字占领高地，成为新的候选人 x，血量设为 1。**如果是友军（num == x）：** 血量 +1。**如果是敌军（num != x）：** 发生战斗，一换一，血量 -1。
- **结局：** 遍历结束后，剩下的那个 x 就是众数。

简洁版代码：

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int x = 0, votes = 0;
        for (int num: nums)
        {
            if (votes == 0) x = num;
            votes += (num == x) ? 1: -1;
        }
        return x;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        // x: 当前的候选众数
        // votes: 当前候选人的票数 (或者说“血量”)
        int x = 0, votes = 0;
        
        // 遍历整个数组
        for (int num: nums)
        {
            // 1. 票数归零，改朝换代
            // 说明之前的候选人和这一段路上的敌人同归于尽了
            // 此时遇到的这个新数字 num 成为新的候选人
            if (votes == 0) x = num;
            
            // 2. 投票/抵消阶段
            // 如果 num 是自己人 (num == x)，票数 +1
            // 如果 num 是敌人 (num != x)，发生一换一消耗，票数 -1
            votes += (num == x) ? 1 : -1;
        }
        
        // 由于题目保证众数一定存在且数量 > n/2
        // 经过一轮抵消后，幸存者 x 必定是众数
        return x;
    }
};
```

