# 338. 比特位计数

解题思路拆解

**1. 核心直觉：二进制的“继承”关系**
*   观察一个数字 $i$ 的二进制：比如 $6$ 的二进制是 `110`。
*   如果你把 $6$ 向右移一位（即 $6/2 = 3$），二进制变成了 `11`。
*   **发现：** $6$ 的 1 的个数，其实就等于 $3$ 的 1 的个数，再看 $6$ 的最后一位是不是 1。

**2. 递推公式推导**
对于任意整数 $i$：
*   **左半部分：** 把 $i$ 往右移一位（二进制去掉最后一位），得到的数字是 `i / 2`。这个数字比 $i$ 小，所以它的 1 的个数我们已经算好并存在了 `ans[i/2]` 里。
*   **右半部分：** 刚才去掉的那最后一位。如果 $i$ 是奇数，那最后一位就是 1；如果 $i$ 是偶数，最后一位就是 0。这正好对应了 `i % 2`。
*   **结论：** `ans[i] = ans[i / 2] + (i % 2)`。

**3. 举例说明**
*   计算 `ans[7]`：
    *   $7$ 的二进制是 `111`。
    *   $7 / 2 = 3$。$3$ 的二进制是 `11`，`ans[3] = 2`。
    *   $7 \% 2 = 1$。
    *   所以 `ans[7] = 2 + 1 = 3`。

简洁版代码：

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        if (n == 0) return {0};
        if (n == 1) return {0, 1};
        vector<int> ans = {0, 1};
        for (int i = 2; i <= n; i ++)
        {
            ans.push_back(ans[i/2] + ans[i%2]);
        }
        return ans;
    }
};
```

注释版代码：

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        // 1. 特判边界情况
        if (n == 0) return {0};
        if (n == 1) return {0, 1};
        
        // 2. 初始化结果数组
        // ans[0] = 0, ans[1] = 1 是已知的最基础结果
        vector<int> ans = {0, 1};
        
        // 3. 动态规划填表
        // 从 2 开始一直计算到 n
        for (int i = 2; i <= n; i ++)
        {
            // 核心状态转移方程：
            // ans[i/2] 是 i 去掉二进制最后一位后的 1 的个数
            // ans[i%2] 是判断 i 的二进制最后一位是不是 1
            ans.push_back(ans[i/2] + ans[i%2]);
        }
        
        return ans;
    }
};
```

