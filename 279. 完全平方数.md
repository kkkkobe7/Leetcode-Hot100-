# 279. 完全平方数

解题思路拆解

**1. 建模：完全背包问题**
*   **物品**：完全平方数 ($i^2$)。只要 $i^2 \le n$，这个数就可以用。
*   **物品数量**：无限。每个平方数可以重复使用。
*   **背包容量**：目标整数 $n$。
*   **目标**：装满容量为 $n$ 的背包，所使用的物品**数量最少**。

**2. 定义状态 (DP State)**
*   `dp[j]`：凑成整数 `j` 所需的最少完全平方数的数量。

**3. 状态转移逻辑 (Transition)**
*   假设我们现在正在考虑一个完全平方数 $a = i^2$。
*   如果我们决定使用一个 $a$ 来凑出 $j$，那么我们需要知道凑出 $j-a$ 需要的最少数量，再加上这 1 个 $a$。
*   公式：`dp[j] = min(dp[j], dp[j - a] + 1)`

**4. 初始状态与“无穷大”**
*   `dp[0] = 0`：凑出 0 不需要任何平方数。
*   `dp[其他] = 1e4 (或者某个很大的数)`：因为我们要取最小值，初始化为一个很大的数，防止初始值干扰 `min` 函数。

**5. 循环顺序**
*   **外层循环**：遍历所有可能的物品（即 $1^2, 2^2, 3^2 \dots$ 直到 $i^2 > n$）。
*   **内层循环**：正序遍历容量 $j$（从 $a$ 到 $n$）。正序遍历代表每个物品可以被**重复选取**。

简洁版代码：

```c++
class Solution {
public:
    static const int N = 1e4+10;
    int dp[N];

    int numSquares(int n) {
        for (int i = 1; i <= n; i ++) dp[i] = 1e4;
        for (int i = 1; i*i <= n; i ++)
        {
            int a = i * i;
            for (int j = a; j <= n; j ++)
            {
                dp[j] = min(dp[j-a] + 1, dp[j]);
            }
        }

        return dp[n];
        
    }
};
```

注释版代码：

```c++
class Solution {
public:
    // N 定义为 1e4 + 10，覆盖了题目范围 (n <= 10000)
    static const int N = 1e4 + 10;
    int dp[N];

    int numSquares(int n) {
        // 1. 初始化
        // dp[0] 默认为 0 (静态数组或显式赋值)
        // 其余位置初始化为一个不可能的大数 (这里用 1e4，因为最多也就是由 n 个 1 组成)
        for (int i = 1; i <= n; i ++) dp[i] = 1e4;
        dp[0] = 0; 

        // 2. 遍历“物品”：即所有小于等于 n 的完全平方数
        // i*i 代表当前选取的完全平方数
        for (int i = 1; i * i <= n; i ++)
        {
            int a = i * i; // 当前面额
            
            // 3. 遍历“背包容量”：凑成的和 j
            // 正序遍历表示完全平方数 a 可以无限次使用
            for (int j = a; j <= n; j ++)
            {
                // 核心状态转移方程：
                // 保持原样 (不选当前 a) 
                // 或者 使用一个 a (1 + 剩余金额 j-a 所需的最少数量)
                dp[j] = min(dp[j], dp[j - a] + 1);
            }
        }

        // 4. 返回目标值
        return dp[n];
    }
};
```

